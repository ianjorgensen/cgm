<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>CGM Viewer — Scroll + Zoom</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body { font: 12px system-ui, sans-serif; margin: 16px; color:#111; }
  .wrap { max-width: 1200px; }
  #chart { border: 1px solid #e5e5e5; background:#fff; }
  #mini  { border: 1px solid #eee; background:#fafafa; }
  .row { margin: 10px 0; }
  .legend { margin-left: 8px; color:#555; }
  .hud { position: relative; }
  .tooltip {
    position:absolute; pointer-events:none; background:#fff; border:1px solid #ddd;
    padding:4px 6px; border-radius:4px; font-size:11px; transform:translate(-50%,-120%);
  }
</style>

<body>
<div class="wrap">
  <div class="row">
    <button id="reset">Reset zoom</button>
    <span class="legend">Scroll to zoom (X-only), drag to pan. Brush the mini chart to jump.</span>
  </div>

  <div class="row hud" style="position:relative;">
    <canvas id="chart" width="1200" height="380"></canvas>
    <div id="tip" class="tooltip" style="display:none;"></div>
  </div>

  <div class="row">
    <svg id="mini" width="1200" height="100"></svg>
  </div>
</div>

<script type="module">
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
import { units, t0, stepMs, glucose } from "./cgm_data.js";

const W = 1200, H = 380, M = {t:20,r:50,b:30,l:50};
const canvas = document.getElementById("chart");
const ctx = canvas.getContext("2d", { alpha: false });
const tip = document.getElementById("tip");

// Build time grid
const tStart = new Date(t0).getTime();
const time = Float64Array.from({length: glucose.length}, (_, i) => tStart + i*stepMs);
const values = Float64Array.from(glucose);
const tDomain = [time[0], time[time.length-1]];
const yDomain = d3.extent(values);

// Scales (data → pixels)
const x = d3.scaleTime().domain(tDomain).range([M.l, W - M.r]);
const y = d3.scaleLinear().domain(yDomain).nice().range([H - M.b, M.t]);

// Axes (SVG overlaid on top of canvas using foreignObject-free trick)
const axisCanvas = document.createElement("canvas");
axisCanvas.width = W; axisCanvas.height = H;
axisCanvas.style.position = "absolute"; axisCanvas.style.left = "0"; axisCanvas.style.top = "0";
canvas.parentElement.appendChild(axisCanvas);
const ax = axisCanvas.getContext("2d");

// Mini overview
const miniH = 100, miniSvg = d3.select("#mini");
const miniX = d3.scaleTime().domain(tDomain).range([M.l, W - M.r]);
const miniY = d3.scaleLinear().domain(y.domain()).range([miniH-20, 10]);

// Downsample helper: 1 sample per pixel column in current view
function drawSeries(ctx, xScale, yScale){
  const pxLeft = M.l, pxRight = W - M.r;
  const t0v = xScale.invert(pxLeft).getTime();
  const t1v = xScale.invert(pxRight).getTime();
  const idx0 = Math.max(0, Math.floor((t0v - time[0]) / stepMs));
  const idx1 = Math.min(values.length-1, Math.ceil((t1v - time[0]) / stepMs));

  const span = Math.max(1, idx1 - idx0);
  const pixels = Math.max(1, pxRight - pxLeft);
  const bucket = Math.max(1, Math.floor(span / pixels)); // points per pixel bucket

  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "#fff"; ctx.fillRect(0,0,W,H);

  // gridlines
  ctx.strokeStyle = "#f0f0f0"; ctx.lineWidth = 1;
  for (const t of xScale.ticks(10)){
    const xpx = Math.round(xScale(t));
    ctx.beginPath(); ctx.moveTo(xpx, M.t); ctx.lineTo(xpx, H-M.b); ctx.stroke();
  }
  for (const g of yScale.ticks(6)){
    const ypx = Math.round(yScale(g));
    ctx.beginPath(); ctx.moveTo(M.l, ypx); ctx.lineTo(W-M.r, ypx); ctx.stroke();
  }

  // series (min-max envelope per bucket)
  ctx.strokeStyle = "#000"; ctx.lineWidth = 1;
  for (let i = idx0; i <= idx1; i += bucket){
    const ii = Math.min(i + bucket - 1, idx1);
    let vmin= Infinity, vmax= -Infinity, tmid = time[i + Math.floor((ii-i)/2)];
    for (let k=i; k<=ii; k++){ const v=values[k]; if (v<vmin) vmin=v; if (v>vmax) vmax=v; }
    const xp = xScale(new Date(tmid));
    const y1 = yScale(vmin), y2 = yScale(vmax);
    ctx.beginPath(); ctx.moveTo(xp, y1); ctx.lineTo(xp, y2); ctx.stroke();
  }

  // axes on separate canvas for crispness
  ax.clearRect(0,0,W,H);
  ax.fillStyle="#000"; ax.font="10px system-ui";
  // X axis
  ax.strokeStyle="#000"; ax.lineWidth=1; ax.beginPath();
  ax.moveTo(M.l, H-M.b+0.5); ax.lineTo(W-M.r, H-M.b+0.5); ax.stroke();
  xScale.ticks(6).forEach(t=>{
    const xp = Math.round(xScale(t));
    ax.beginPath(); ax.moveTo(xp, H-M.b); ax.lineTo(xp, H-M.b+5); ax.stroke();
    const label = d3.timeFormat("%b %d")(t);
    ax.fillText(label, xp-12, H-M.b+16);
  });
  // Y axis
  ax.beginPath(); ax.moveTo(M.l-0.5, M.t); ax.lineTo(M.l-0.5, H-M.b); ax.stroke();
  yScale.ticks(6).forEach(v=>{
    const yp = Math.round(yScale(v));
    ax.beginPath(); ax.moveTo(M.l-5, yp); ax.lineTo(M.l, yp); ax.stroke();
    ax.fillText(v.toFixed(0), M.l-35, yp+3);
  });
  ax.fillText(`CGM (${units})`, M.l, M.t-6);
}

// initial draw
drawSeries(ctx, x, y);

// Mini overview path (downsample to ~1200 columns)
const miniPath = (() => {
  const px = Math.floor(W - M.l - M.r);
  const stride = Math.max(1, Math.floor(values.length / px));
  const line = d3.line()
    .x((d,i)=>miniX(new Date(time[i*stride])))
    .y(d=>miniY(d));
  const arr = [];
  for (let i=0;i<values.length;i+=stride) arr.push(values[i]);
  return miniSvg.append("path").attr("d", line(arr)).attr("fill","none").attr("stroke","#222");
})();

// Brush to set visible window
const brush = d3.brushX()
  .extent([[M.l, 10],[W-M.r, miniH-20]])
  .on("brush end", ({selection})=>{
    if (!selection) return;
    const [a,b] = selection.map(miniX.invert);
    x.domain([+a, +b]);
    drawSeries(ctx, x, y);
  });
miniSvg.append("g").attr("class","brush").call(brush)
  .call(g=>g.call(brush.move, [M.l, M.l+ (W-M.l-M.r)/3])); // start with ~1/3 window

// Zoom/pan (X-only)
const zoom = d3.zoom()
  .scaleExtent([1, 200]) // allow up to 200× zoom
  .translateExtent([[M.l, -Infinity],[W-M.r, Infinity]])
  .on("zoom", (ev)=>{
    const t = ev.transform;
    // convert transform to new X domain
    const zx = t.rescaleX(d3.scaleTime().domain(tDomain).range([M.l, W-M.r]));
    x.domain(zx.domain());
    drawSeries(ctx, x, y);

    // sync brush window
    const [a,b] = x.domain().map(d=>miniX(d));
    miniSvg.select(".brush").call(brush.move, [a,b]);
  });
d3.select(canvas).call(zoom).on("dblclick.zoom", null);

// Reset
document.getElementById("reset").onclick = ()=>{
  x.domain(tDomain);
  drawSeries(ctx, x, y);
  miniSvg.select(".brush").call(brush.move, [M.l, W-M.r]);
};

// Tooltip
canvas.addEventListener("mousemove", (e)=>{
  const rect = canvas.getBoundingClientRect();
  const px = e.clientX - rect.left;
  const py = e.clientY - rect.top;
  if (px < M.l || px > W-M.r || py < M.t || py > H-M.b) { tip.style.display="none"; return; }
  const t = x.invert(px).getTime();
  const idx = Math.min(values.length-1, Math.max(0, Math.round((t - time[0]) / stepMs)));
  tip.style.display = "block";
  tip.style.left = (px)+"px";
  tip.style.top  = (py)+"px";
  const dt = new Date(time[idx]);
  tip.textContent = `${d3.timeFormat("%Y-%m-%d %H:%M")(dt)} — ${values[idx].toFixed(1)} ${units}`;
});
canvas.addEventListener("mouseleave", ()=> tip.style.display="none");
</script>
</body>
</html>
