<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>CGM Viewer — Full‑Range Navigation</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body { font: 12px system-ui, sans-serif; margin: 16px; color:#111; }
  #chart { border:none; background:#fff; max-width:100%; height:auto; display:block; }
  .legend { margin-left:8px; color:#555; }
  .tooltip { position:fixed; pointer-events:none; background:#fff; border:1px solid #ddd; padding:4px 6px; border-radius:4px; font-size:11px; transform:translate(-50%,-120%); z-index:10000; }
  .bands-legend { display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; margin-top:6px; color:#444; }
  .sw { width:14px; height:10px; border-radius:2px; display:inline-block; margin-right:4px; }
  .footer { font-size:12px; color:#555; text-align:center; margin:12px 0; }
  .bottombar { position: sticky; bottom: 0; background:#fff; border-top:1px solid #eee; z-index: 10; padding:8px 0; }
  .container { max-width:1200px; margin:0 auto; }
  #summary { margin: 42px 0px; padding: 10px 0 !important;}
  #tir { margin-top:20px; text-align:left; }
  #tir svg { display:block; margin:0; overflow: visible; }
  .pct { font-weight:600; font-size:12px; }
  .goal { font-size:10px; fill:#666; }
  .muted { color:#777; font-size:12px; }
  .metric { display:flex; justify-content:space-between; padding:8px 10px; border-bottom:1px solid #eee; }
  .metric:last-child { border-bottom:none; }
  .agp-wrap { position:relative; height:280px; }
  .agp-wrap > svg { position:absolute; inset:0; width:100%; height:100%; }
  .agp-placeholder { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; text-align:center; color:#555; font-size:16px; font-weight:600; }
  /* Brush styling */
  #fullRange .selection { fill: #f7c6d9; fill-opacity: 0.45; stroke: none; }
  #fullRange .handle { stroke: none; fill: #f7c6d9; fill-opacity: 0.30; }
</style>

<body>
  <div class="container">
    <div style="display:flex; gap:16px; align-items:flex-start; margin-top:12px;">
      <div style="flex:1 1 0; min-width:0;">
        <div id="summary" style="border:1px solid #e6e6e6; border-radius:8px; padding:10px; background:#fff;">
          <div class="metric"><div><b>Report Period</b></div><div id="sumPeriod"></div></div>
          <div class="metric"><div><b>Time CGM Active</b></div><div id="sumActive"></div></div>
          <div class="metric"><div><b>Average Glucose</b><div class="muted">Goal: &lt;154 mg/dL (8.6 mmol/L)</div></div><div id="sumAvg"></div></div>
          <div class="metric"><div><b>Glucose Management Indicator (GMI)</b><div class="muted">Goal: &lt;7%</div></div><div id="sumGmi"></div></div>
          <div class="metric"><div><b>Glucose Variability (CV)</b><div class="muted">Goal: ≤36%</div></div><div id="sumCv"></div></div>
        </div>
        <div id="tir" style="margin-top:16px;"></div>
      </div>
      <div style="flex:3 1 0; min-width:0;">
        <div id="agpSection" class="agp-wrap">
          <svg id="agpSvg"></svg>
          <div id="agpMsg" class="agp-placeholder" style="display:none;">Not enough data available to compute AGP profile</div>
        </div>
        <div id="chartWrap" style="position:relative;">
          <canvas id="chart" width="1200" height="260"></canvas>
          <div id="tip" class="tooltip" style="display:none;"></div>
          <div id="chartMsg" class="agp-placeholder" style="display:none; height:260px;">Too much data for daily view</div>
        </div>
        <div id="bandsLegend" class="bands-legend" style="margin-top:8px;"></div>
      </div>
    </div>
  </div>

  <div class="bottombar">
    <div class="container">
      <svg id="fullRange" height="120" style="width:100%;"></svg>
      <div class="footer"><span class="kbd">?</span> to view keyboard shortcuts</div>
    </div>
  </div>

  <div id="tipFull" class="tooltip" style="display:none;"></div>

<script type="module">
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
import { units, t0, stepMs, glucose } from "./cgm_data.js";

const W=1200,H=260,M={t:20,r:50,b:30,l:50};
const canvas=document.getElementById("chart");
const ctx=canvas.getContext("2d",{alpha:false});
function getCanvasWidth(){ return Math.max(300, Math.floor(canvas.getBoundingClientRect().width||1200)); }
canvas.width = getCanvasWidth();
let CW = canvas.width; canvas.height = H;
const tip=document.getElementById("tip");

const tStart=new Date(t0).getTime();
const time=Float64Array.from({length:glucose.length},(_,i)=>tStart+i*stepMs);
const values=Float64Array.from(glucose);
const tDomain=[time[0],time[time.length-1]];
const validValues = Array.from(values).filter(v=>Number.isFinite(v) && v>=0);
const yDomain=(validValues.length? d3.extent(validValues) : [0,10]);

const x=d3.scaleTime().domain(tDomain).range([M.l,CW-M.r]);
const y=d3.scaleLinear().domain(yDomain).nice().range([H-M.b,M.t]);

const isMmol = /mmol/i.test(units);
const TH = isMmol ? { vlow:3.0, low:3.9, high:10.0, vhigh:13.9 } : { vlow:54, low:70, high:180, vhigh:250 };
const COLORS = { vlow:"#b30000", low:"#e34a33", targ:"#1a9850", high:"#fdae61", vhigh:"#f46d43" };
function bandOf(v){ if (v < TH.vlow) return "vlow"; if (v < TH.low) return "low"; if (v <= TH.high) return "targ"; if (v <= TH.vhigh) return "high"; return "vhigh"; }

function drawSeries(){
  const pxLeft=M.l,pxRight=canvas.width-M.r;
  const t0v=x.invert(pxLeft).getTime(), t1v=x.invert(pxRight).getTime();
  const idx0=Math.max(0,Math.floor((t0v-time[0])/stepMs));
  const idx1=Math.min(values.length-1,Math.ceil((t1v-time[0])/stepMs));

  ctx.clearRect(0,0,canvas.width,H);
  ctx.fillStyle="#fff"; ctx.fillRect(0,0,canvas.width,H);

  const dayMs=24*60*60*1000;
  const tooWide=(t1v-t0v)>90*dayMs;
  document.getElementById('chartMsg').style.display = tooWide?'flex':'none';
  if (tooWide){ return; }

  // thresholds
  ctx.strokeStyle="#1a9850"; ctx.lineWidth=2;
  [TH.low,TH.high].forEach(val=>{ const yy=y(val); ctx.beginPath(); ctx.moveTo(M.l,yy); ctx.lineTo(canvas.width-M.r,yy); ctx.stroke(); });

  // grid
  ctx.strokeStyle="#f0f0f0"; ctx.lineWidth=1;
  for(const t of x.ticks(10)){ const xp=Math.round(x(t)); ctx.beginPath(); ctx.moveTo(xp,M.t); ctx.lineTo(xp,H-M.b); ctx.stroke(); }
  for(const g of y.ticks(6)){ const yp=Math.round(y(g)); ctx.beginPath(); ctx.moveTo(M.l,yp); ctx.lineTo(canvas.width-M.r,yp); ctx.stroke(); }

  // dots
  const buckets={vlow:[],low:[],targ:[],high:[],vhigh:[]};
  for(let i=idx0;i<=idx1;i++){
    const v=values[i]; if(!(Number.isFinite(v)&&v>=0)) continue;
    const px=x(new Date(time[i])); const py=y(v); const b=bandOf(v);
    buckets[b].push(px,py);
  }
  const r=1.5; for(const k of Object.keys(buckets)){ const arr=buckets[k]; if(!arr.length) continue; ctx.fillStyle=COLORS[k]; ctx.beginPath(); for(let j=0;j<arr.length;j+=2){ const px=arr[j],py=arr[j+1]; ctx.moveTo(px+r,py); ctx.arc(px,py,r,0,Math.PI*2);} ctx.fill(); }

  // axes
  ctx.strokeStyle="#000"; ctx.fillStyle="#000"; ctx.lineWidth=1; ctx.font="10px system-ui";
  ctx.beginPath(); ctx.moveTo(M.l,H-M.b+0.5); ctx.lineTo(canvas.width-M.r,H-M.b+0.5); ctx.stroke();
  const [xd0,xd1]=x.domain(); const spanMs=(+xd1)-(+xd0); const oneDay=24*60*60*1000; let xticks,fmt,off;
  const timeHM=d3.timeFormat('%H:%M'); const monthShort=d3.timeFormat('%b'); function ordinal(n){const j=n%10,k=n%100; if(j===1&&k!==11)return n+'st'; if(j===2&&k!==12)return n+'nd'; if(j===3&&k!==13)return n+'rd'; return n+'th';}
  function fmtAxisDate(d){ return `${monthShort(d)} ${ordinal(d.getDate())}`; }
  if(spanMs<=oneDay*2){ const every= spanMs<=oneDay?2:3; xticks=x.ticks(d3.timeHour.every(every)); fmt=timeHM; off=-12; } else { xticks=x.ticks(6); fmt=fmtAxisDate; off=-18; }
  xticks.forEach(t=>{ const xp=Math.round(x(t)); ctx.beginPath(); ctx.moveTo(xp,H-M.b); ctx.lineTo(xp,H-M.b+5); ctx.stroke(); ctx.fillText(fmt(t), xp+off, H-M.b+16); });
}
drawSeries();

// resize
window.addEventListener('resize', ()=>{ const w=getCanvasWidth(); if(w!==canvas.width){ canvas.width=w; x.range([M.l, canvas.width-M.r]); drawSeries(); renderFullRange(); } });

// main chart tooltip
canvas.addEventListener('mousemove',e=>{ const rect=canvas.getBoundingClientRect(); const px=e.clientX-rect.left,py=e.clientY-rect.top; if(px<M.l||px>canvas.width-M.r||py<M.t||py>H-M.b){tip.style.display='none';return;} const tval=x.invert(px).getTime(); const idx=Math.min(values.length-1,Math.max(0,Math.round((tval-time[0])/stepMs))); const v=values[idx]; if(!(Number.isFinite(v)&&v>=0)){ tip.style.display='none'; return;} tip.style.display='block'; tip.style.left=px+'px'; tip.style.top=py+'px'; const monthShort=d3.timeFormat('%b'); function ordinal(n){const j=n%10,k=n%100; if(j===1&&k!==11)return n+'st'; if(j===2&&k!==12)return n+'nd'; if(j===3&&k!==13)return n+'rd'; return n+'th';} const td=new Date(time[idx]); tip.textContent=`${monthShort(td)} ${ordinal(td.getDate())} ${td.getFullYear()} - ${d3.timeFormat('%H:%M')(td)} — ${v.toFixed(1)} ${units}`; });
canvas.addEventListener('mouseleave',()=>tip.style.display='none');

// domain helpers (min 1d, max 1y)
function setDomain(d0,d1){ const min=+tDomain[0], max=+tDomain[1]; d0=Math.max(min,Math.min(max,d0)); d1=Math.max(min,Math.min(max,d1)); const day=24*60*60*1000, year=365*day; let span=d1-d0; if(span<day){ const c=(d0+d1)/2; d0=Math.max(min,Math.min(max-day,c-day/2)); d1=d0+day; span=d1-d0; } if(span>year){ const c=(d0+d1)/2; d0=Math.max(min,Math.min(max-year,c-year/2)); d1=d0+year; } x.domain([d0,d1]); drawSeries(); }

// full-range chart (percent TIR per day) with brush navigation
function renderFullRange(){
  const svg=d3.select('#fullRange'); if(svg.empty())return; svg.selectAll('*').remove();
  const bbox=svg.node().getBoundingClientRect(); const Wf=Math.max(360,bbox.width||600); const Hf=120; const m={l:M.l,r:M.r,t:8,b:20};
  const xF=d3.scaleTime().domain(tDomain).range([m.l,Wf-m.r]); const yF=d3.scaleLinear().domain([0,100]).range([Hf-m.b,m.t]);

  const dayMs=24*60*60*1000; const byDay=new Map();
  for(let i=0;i<values.length;i++){ const v=values[i]; if(!(Number.isFinite(v)&&v>=0)) continue; const d=new Date(time[i]); const ds=new Date(d.getFullYear(),d.getMonth(),d.getDate()).getTime(); let rec=byDay.get(ds); if(!rec){ rec={valid:0,targ:0}; byDay.set(ds,rec);} rec.valid++; if(v>=TH.low&&v<=TH.high) rec.targ++; }
  const samplesPerDay=Math.round(dayMs/stepMs);
  const days=Array.from(byDay.entries()).sort((a,b)=>a[0]-b[0]).map(([t,rec])=>{ const active=rec.valid/samplesPerDay*100; const pct=rec.valid?(rec.targ/rec.valid*100):NaN; return {t:new Date(t+dayMs/2), pct:active>=50?pct:NaN}; });
  const line=d3.line().defined(d=>Number.isFinite(d.pct)).x(d=>xF(d.t)).y(d=>yF(d.pct));
  svg.append('path').attr('d',line(days)).attr('fill','none').attr('stroke',COLORS.targ).attr('stroke-width',1.2);
  svg.append('g').attr('transform',`translate(${m.l},0)`).call(d3.axisLeft(yF).tickValues([0,50,100]).tickFormat(d=>d+'%'))
    .selectAll('text').attr('font-size',10);
  // month axis similar to mini
  const months=d3.timeMonths(d3.timeMonth.floor(new Date(tDomain[0])), new Date(tDomain[1])); const fmtM=d3.timeFormat('%b'); const fmtY=d3.timeFormat("'%y"); const avail=Math.max(60,(Wf-m.l-m.r)); const maxTicks=Math.max(2,Math.floor(avail/40)); const step=Math.max(1,Math.ceil(months.length/maxTicks)); const tickMonths=months.filter((_,i)=>i%step===0); const axisB=d3.axisBottom(xF).tickValues(tickMonths).tickFormat(d=> d.getMonth()===0?`${fmtM(d)} ${fmtY(d)}`:fmtM(d)).tickPadding(6).tickSizeOuter(0).tickSizeInner(3);
  svg.append('g').attr('transform',`translate(0,${Hf-m.b})`).call(axisB).selectAll('text').attr('font-size',10);

  // hover & click
  const tipFull=document.getElementById('tipFull'); const bisect=d3.bisector(d=>d.t).left;
  svg.append('rect').attr('x',m.l).attr('y',m.t).attr('width',Wf-m.l-m.r).attr('height',Hf-m.t-m.b).attr('fill','transparent').style('cursor','pointer')
    .on('mousemove',(event)=>{ const [mx,my]=d3.pointer(event,svg.node()); const tH=xF.invert(mx); let i=bisect(days,tH); i=Math.max(0,Math.min(days.length-1,i)); let cand=days[i]; if(i>0 && Math.abs(+days[i-1].t-+tH)<Math.abs(+cand.t-+tH)) cand=days[i-1]; const rect=svg.node().getBoundingClientRect(); tipFull.style.display='block'; tipFull.style.left=(rect.left+mx)+'px'; tipFull.style.top=(rect.top+my-10)+'px'; const ms=d3.timeFormat('%b'); function ord(n){const j=n%10,k=n%100;if(j===1&&k!==11)return n+'st'; if(j===2&&k!==12)return n+'nd'; if(j===3&&k!==13)return n+'rd'; return n+'th';} const label=`${ms(cand.t)} ${ord(cand.t.getDate())} ${cand.t.getFullYear()}`; tipFull.textContent = Number.isFinite(cand?.pct) ? `${label} — ${cand.pct.toFixed(1)}% TIR` : `${label} — not enough data`; })
    .on('click',(event)=>{ const [mx]=d3.pointer(event,svg.node()); const tH=xF.invert(mx); const d=new Date(tH); const start=new Date(d.getFullYear(),d.getMonth(),d.getDate()).getTime(); setDomain(start, start+24*60*60*1000); })
    .on('mouseleave',()=>{ tipFull.style.display='none'; });

  // Add brush for navigation only here (no syncing back to brush on programmatic changes to keep simple)
  const fullBrush = d3.brushX().handleSize(3).extent([[m.l,m.t],[Wf-m.r,Hf-m.b]]).on('end',({selection})=>{ if(!selection) return; let [a,b]=selection.map(xF.invert); setDomain(+a,+b); });
  const gBrush = svg.append('g').call(fullBrush);
  // initialize brush to current domain
  const [cd0,cd1]=x.domain().map(d=>+d); gBrush.call(fullBrush.move,[xF(cd0),xF(cd1)]);
}
renderFullRange();
</script>
</body>
</html>
