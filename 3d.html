<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>CGM Pan Matrix Profile + Auto-Suggest + 3D Canvas</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body { font: 12px system-ui, sans-serif; margin: 16px; color: #111; }
  .row { margin-bottom: 16px; }
  .axis text { font-size: 10px; }
  .motif { stroke-width: 1.5px; fill: none; }
  #status { margin-left: 8px; }
  .chips { display:flex; gap:8px; flex-wrap:wrap; margin:6px 0 10px; }
  .chip { padding:4px 8px; border-radius:999px; border:1px solid #ddd; cursor:pointer; }
  .chip:hover { background:#f5f5f5; }
</style>

<body>
  <div style="display:flex; gap:8px; align-items:center;">
    <select id="lenSelect"></select>
    <span id="status"></span>
  </div>
  <div class="chips" id="autosuggest"></div>

  <div id="line" class="row"></div>
  <div id="heat" class="row"></div>
  <div id="motifs" class="row"></div>
  <div id="surface" class="row"></div>

<script type="module">
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
import { units, t0, stepMs, glucose } from "./cgm_data.js";

const W = 1200, H1 = 200, H2 = 360, H3 = 140, M = {t:20,r:20,b:30,l:40};
const status = d3.select("#status");
const lenSelect = d3.select("#lenSelect");
const chipsBox = d3.select("#autosuggest");

// build time grid
const tStart = new Date(t0);
const grid = Array.from({length: glucose.length}, (_, i) => ({
  t: new Date(tStart.getTime() + i*stepMs),
  g: +glucose[i]
}));
const series = grid.map(d=>d.g);

// motif lengths (5-min cadence → 288/day)
const lens = [12,18,24,36,48,72,96,120,144,192,240,288,336];
lenSelect.selectAll("option").data(lens).join("option")
  .attr("value", d=>d).text(d=>`m=${d} (${(d*stepMs/3.6e6).toFixed(1)}h)`);

// worker for Pan Matrix Profile
const worker = new Worker(URL.createObjectURL(new Blob([`
  function rollingStats(x,m){const n=x.length,mean=new Float64Array(n-m+1),std=new Float64Array(n-m+1);
    const ps=new Float64Array(n+1),ps2=new Float64Array(n+1);
    for(let i=0;i<n;i++){ps[i+1]=ps[i]+x[i];ps2[i+1]=ps2[i]+x[i]*x[i];}
    for(let i=0;i<=n-m;i++){const s=ps[i+m]-ps[i],s2=ps2[i+m]-ps2[i];
      const mu=s/m,v=Math.max(1e-12,s2/m-mu*mu);mean[i]=mu;std[i]=Math.sqrt(v);}return {mean,std};}
  function znormDist2(x,i,y,j,m,statsX,statsY){
    let dot=0;for(let k=0;k<m;k++)dot+=x[i+k]*y[j+k];
    const muX=statsX.mean[i],muY=statsY.mean[j],sX=statsX.std[i],sY=statsY.std[j];
    const corr=(dot-m*muX*muY)/(m*sX*sY+1e-12);
    return 2*m*(1-Math.max(-1,Math.min(1,corr))); }
  function distProfile(x,m,q,stats){const n=x.length,N=n-m+1,prof=new Float64Array(N).fill(Infinity);
    const ex=Math.floor(m/2);for(let i=0;i<N;i++){if(Math.abs(i-q)<=ex)continue;
      prof[i]=znormDist2(x,i,x,q,m,stats,stats);}return prof;}
  function approxMP(x,m,k=32,seed=1337){const N=x.length-m+1,stats=rollingStats(x,m),mp=new Float64Array(N).fill(Infinity);
    let s=seed>>>0;const rnd=()=> (s=(1664525*s+1013904223)>>>0)/2**32;
    for(let t=0;t<k;t++){const q=Math.floor(rnd()*N);const dp=distProfile(x,m,q,stats);
      for(let i=0;i<N;i++)if(dp[i]<mp[i])mp[i]=dp[i];}return mp;}
  onmessage=(e)=>{const {series,lens,k}=e.data,x=Float64Array.from(series),result=[];
    for(const m of lens){const mp=approxMP(x,m,k);result.push({m,mp:Array.from(mp)});postMessage({progress:true,m});}
    postMessage({done:true,pmp:result});};
`], {type:"application/javascript"})));

status.text("computing…");
worker.postMessage({series, lens, k:32});
const pmp = await new Promise(res=>{
  worker.onmessage = e=>{
    if(e.data.progress) status.text(` computing m=${e.data.m}…`);
    if(e.data.done){status.text("done");res(e.data.pmp);}
  };
});

// ==== top: CGM line ====
const x = d3.scaleTime().domain(d3.extent(grid, d=>d.t)).range([M.l, W-M.r]);
const y = d3.scaleLinear().domain(d3.extent(grid, d=>d.g)).nice().range([H1-M.b, M.t]);
const svg1 = d3.select("#line").append("svg").attr("width", W).attr("height", H1);
svg1.append("path").datum(grid).attr("d",
  d3.line().x(d=>x(d.t)).y(d=>y(d.g))
).attr("fill","none").attr("stroke","currentColor");

// ==== heatmap ====
const timeN = series.length;
const cellW = Math.max(1, Math.floor((W-M.l-M.r)/timeN));
const rowsH = lens.length;
const cellH = Math.max(2, Math.floor((H2-M.t-M.b)/rowsH));
const svg2 = d3.select("#heat").append("svg").attr("width", W).attr("height", H2);

const flat = [];
const maxV = d3.max(pmp, r => d3.max(r.mp));
const minV = d3.min(pmp, r => d3.min(r.mp));
const color = d3.scaleSequential(d3.interpolateTurbo).domain([maxV, minV]);

pmp.forEach((row, j)=>{
  const N = timeN - row.m + 1;
  for (let i=0;i<timeN;i++){
    const v = i<N ? row.mp[i] : row.mp[N-1];
    flat.push({i, j, v});
  }
});
svg2.append("g").selectAll("rect").data(flat).join("rect")
  .attr("x", d=>M.l + d.i*cellW)
  .attr("y", d=>M.t + d.j*cellH)
  .attr("width", cellW)
  .attr("height", cellH)
  .attr("fill", d=>color(d.v));

// ==== bottom: MP for selected m ====
const svg3 = d3.select("#motifs").append("svg").attr("width", W).attr("height", H3);
const y3 = d3.scaleLinear().domain([0, maxV]).range([H3-M.b, M.t]);
const mpLine = d3.line().x((d,i)=>x(grid[i].t)).y(d=>y3(d));
function drawMotifs(m){
  const row = pmp.find(r=>r.m==m);
  svg3.selectAll("*").remove();
  svg3.append("path").datum(row.mp).attr("d", mpLine).attr("class","motif").attr("stroke","currentColor");
}
drawMotifs(+lenSelect.property("value") || lens[0]);
lenSelect.on("change", ()=>drawMotifs(+lenSelect.property("value")));

// ==== auto-suggest ====
function quantile(arr, q){
  const a = Float64Array.from(arr).sort();
  const pos = (a.length-1)*q, b = Math.floor(pos), r = pos-b;
  return a[b] + (a[Math.min(b+1, a.length-1)]-a[b])*(r||0);
}
const scored = pmp.map(r => ({ m: r.m, score: quantile(r.mp, 0.05) }))
  .sort((a,b)=>a.score-b.score).slice(0,3);
chipsBox.selectAll("div.chip").data(scored).join("div")
  .attr("class","chip")
  .text(d => `Try m=${d.m} (${(d.m*stepMs/3.6e6).toFixed(1)}h)`)
  .on("click", (e,d) => { lenSelect.property("value", d.m); drawMotifs(d.m); });

// ==== 3D surface on canvas ====
const W3 = 1000, H3D = 520;
const canvas = d3.select("#surface").append("canvas")
  .attr("width", W3).attr("height", H3D).node();
const ctx = canvas.getContext("2d");
ctx.font = "12px system-ui";
ctx.fillText("3D Pan Matrix Profile (valleys = strong motifs)", 40, 20);

const strideX = Math.max(1, Math.floor(timeN / 800));
const strideY = Math.max(1, Math.floor(lens.length / 40));
const rows3d = [];
for (let j=0;j<pmp.length;j+=strideY){
  const row = pmp[j];
  const N = timeN - row.m + 1;
  const arr = new Float32Array(Math.ceil(timeN/strideX));
  let idx=0;
  for (let i=0;i<timeN;i+=strideX){
    const ii = Math.min(i,N-1);
    arr[idx++] = row.mp[Math.max(0,ii)];
  }
  rows3d.push({ j, m: row.m, mp: arr });
}
const cols3d = rows3d[0].mp.length;

const origin=[W3/2, H3D/2+60];
const sx=(W3-200)/cols3d, sy=10, sz=0.25;
let beta=0, alpha=0.9;
function project(ix,jy,v){
  const x0=(ix-cols3d/2)*sx;
  const y0=((jy/strideY)-lens.length/2)*sy;
  const z0=(v-(minV+maxV)/2)*sz;
  const cosA=Math.cos(alpha), sinA=Math.sin(alpha);
  const cosB=Math.cos(beta), sinB=Math.sin(beta);
  const X=cosB*x0+sinB*z0, Z=-sinB*x0+cosB*z0;
  const Y=cosA*y0-sinA*Z; return {x:origin[0]+X, y:origin[1]-Y, z:sinA*y0+cosA*Z};
}
const color3D=d3.scaleSequential(d3.interpolateTurbo).domain([maxV,minV]);
const faces=[];
for(let r=0;r<rows3d.length-1;r++){
  const a=rows3d[r], b=rows3d[r+1];
  for(let c=0;c<cols3d-1;c++){
    const v=(a.mp[c]+a.mp[c+1]+b.mp[c]+b.mp[c+1])/4;
    faces.push({v,r,c,pts:[
      {ix:c,jy:a.j,v:a.mp[c]}, {ix:c+1,jy:a.j,v:a.mp[c+1]},
      {ix:c+1,jy:b.j,v:b.mp[c+1]}, {ix:c,jy:b.j,v:b.mp[c]}
    ]});
  }
}
function renderSurface(){
  const draw=faces.map(f=>{
    const P=f.pts.map(p=>project(p.ix,p.jy,p.v));
    const zavg=(P[0].z+P[1].z+P[2].z+P[3].z)/4;
    return {P,z:zavg,c:color3D(f.v)};
  }).sort((a,b)=>a.z-b.z);
  ctx.clearRect(0,0,W3,H3D);
  ctx.fillStyle="#000"; ctx.fillText("3D Pan Matrix Profile (valleys = strong motifs)",40,20);
  for(const d of draw){
    ctx.beginPath();
    ctx.moveTo(d.P[0].x,d.P[0].y);
    for(let k=1;k<4;k++) ctx.lineTo(d.P[k].x,d.P[k].y);
    ctx.closePath(); ctx.fillStyle=d.c; ctx.fill();
  }
}
(function animate(){ beta+=0.01; renderSurface(); requestAnimationFrame(animate); })();
</script>
</body>
</html>
