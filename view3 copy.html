<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>CGM Viewer — Dots by Range + Vertical TIR</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body { font: 12px system-ui, sans-serif; margin: 16px; color:#111; }
  #chart { border:1px solid #e5e5e5; background:#fff; max-width:100%; height:auto; display:block; }
  #mini  { border:1px solid #eee;}
  .legend { margin-left:8px; color:#555; }
  .tooltip {
    position:absolute; pointer-events:none; background:#fff; border:1px solid #ddd;
    padding:4px 6px; border-radius:4px; font-size:11px; transform:translate(-50%,-120%);
  }
  #tir { margin-top:20px; text-align:left; }
  #tir svg { display:block; margin:0; }
  .pct { font-weight:600; font-size:12px; }
  .goal { font-size:10px; fill:#666; }
  .bands-legend { display:flex; gap:10px; align-items:center; margin-top:6px; color:#444; }
  .sw { width:14px; height:10px; border-radius:2px; display:inline-block; margin-right:4px; }
  .muted { color:#777; font-size:12px; }
  .metric { display:flex; justify-content:space-between; padding:8px 10px; border-bottom:1px solid #eee; }
  .metric:last-child { border-bottom:none; }
  .layout { display:grid; grid-template-columns: 320px 1fr; gap:16px; align-items:start; max-width:1200px; }
  .topbar { position: sticky; top: 0; background:#fff; z-index: 10; padding:8px 0; border-bottom:1px solid #eee; }
  .topbar .actions { display:flex; flex-wrap:wrap; align-items:center; gap:10px; }
  .sticky-mini { position: sticky; top: var(--topbar-h, 44px); z-index: 9; }
  .topbar-row { display:flex; gap:12px; align-items:center; }
  .summary-compact { display:grid; grid-template-columns: repeat(2, auto); gap:6px 16px; align-items:baseline; font-size:12px; }
  .summary-compact b { font-weight:600; margin-right:6px; }
  .bottombar { position: sticky; bottom: 0; background:#fff; border-top:1px solid #eee; z-index: 10; padding:8px 0; }
  .container { max-width:1200px; margin:0 auto; }
</style>

<body>
  <div class="topbar">
    <div class="container topbar-row">
      <div class="actions">
        <span class="legend">Drag to pan. W/S = zoom. ←/→ = scroll.</span>
        <div style="display:flex; gap:8px; align-items:center;">
          <span>Window:</span>
          <button id="span1d">1 day</button>
          <button id="span7d">7 days</button>
          <button id="span14d">14 days</button>
          <button id="span1m">1 month</button>
          <button id="spanFull">Full</button>
        </div>
      </div>
      <svg id="mini" height="120" style="flex:1 1 auto; width:100%;"></svg>
    </div>
  </div>

  <div class="container">
    <!-- Two-column layout: Left (1/4) TIR+Summary, Right (3/4) AGP+Chart -->
    <div style="display:flex; gap:16px; align-items:flex-start; margin-top:12px;">
    <!-- Left column (1/4) -->
    <div style="flex:1 1 0; min-width:0;">
      <div id="summary" style="border:1px solid #e6e6e6; border-radius:8px; padding:10px; background:#fff;">
        <div class="metric"><div><b>Report Period</b></div><div id="sumPeriod"></div></div>
        <div class="metric"><div><b>Time CGM Active</b></div><div id="sumActive"></div></div>
        <div class="metric"><div><b>Average Glucose</b><div class="muted">Goal: &lt;154 mg/dL (8.6 mmol/L)</div></div><div id="sumAvg"></div></div>
        <div class="metric"><div><b>Glucose Management Indicator (GMI)</b><div class="muted">Goal: &lt;7%</div></div><div id="sumGmi"></div></div>
        <div class="metric"><div><b>Glucose Variability (CV)</b><div class="muted">Goal: ≤36%</div></div><div id="sumCv"></div></div>
      </div>
      <div id="tir" style="margin-top:16px;"></div>
    </div>

    <!-- Right column (3/4) -->
    <div style="flex:3 1 0; min-width:0;">
      <div style="font-weight:600; margin-bottom:4px; display:flex; gap:10px; align-items:baseline;">
        <span>AGP — Selected Period</span>
        <span id="agpMeta" style="font-weight:400; color:#555; font-size:12px;"></span>
      </div>
      <svg id="agpSvg" style="width:100%; height:280px;"></svg>

      <div id="bandsLegend" class="bands-legend" style="margin-top:12px;"></div>
      <div style="position:relative;">
        <canvas id="chart" width="1200" height="380"></canvas>
        <div id="tip" class="tooltip" style="display:none;"></div>
      </div>
    </div>
  </div>

<script type="module">
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
import { units, t0, stepMs, glucose } from "./cgm_data.js";

const W=1200,H=380,M={t:20,r:50,b:30,l:50};
const canvas=document.getElementById("chart");
const ctx=canvas.getContext("2d",{alpha:false});
const tip=document.getElementById("tip");

const tStart=new Date(t0).getTime();
const time=Float64Array.from({length:glucose.length},(_,i)=>tStart+i*stepMs);
const values=Float64Array.from(glucose);
const tDomain=[time[0],time[time.length-1]];
const yDomain=d3.extent(values);

const x=d3.scaleTime().domain(tDomain).range([M.l,W-M.r]);
const y=d3.scaleLinear().domain(yDomain).nice().range([H-M.b,M.t]);

const isMmol = /mmol/i.test(units);
const TH = isMmol
  ? { vlow:3.0, low:3.9, high:10.0, vhigh:13.9, label:"mmol/L" }
  : { vlow:54,  low:70,  high:180,  vhigh:250,  label:"mg/dL" };
const toMg = v => isMmol ? v*18 : v;

// colors + helpers
const COLORS = { vlow:"#b30000", low:"#e34a33", targ:"#1a9850", high:"#fdae61", vhigh:"#f46d43" };
function bandOf(v){
  if (v < TH.vlow) return "vlow";
  if (v < TH.low)  return "low";
  if (v <= TH.high) return "targ";
  if (v <= TH.vhigh) return "high";
  return "vhigh";
}
function renderLegend(){
  const box = document.getElementById("bandsLegend");
  box.innerHTML = "";
  const legend = [
    {c:COLORS.vlow,  t:`Very Low < ${TH.vlow} ${units}`},
    {c:COLORS.low,   t:`Low ${isMmol?'3.0–3.9':'54–70'} ${units}`},
    {c:COLORS.targ,  t:`Target ${isMmol?'3.9–10.0':'70–180'} ${units}`},
    {c:COLORS.high,  t:`High ${isMmol?'10.0–13.9':'180–250'} ${units}`},
    {c:COLORS.vhigh, t:`Very High > ${TH.vhigh} ${units}`}
  ];
  legend.forEach(d=>{
    const span = document.createElement("span");
    const sw = document.createElement("span"); sw.className="sw"; sw.style.background=d.c;
    span.appendChild(sw); span.appendChild(document.createTextNode(d.t));
    box.appendChild(span);
  });
}
renderLegend();

// ---- draw series (as colored dots) ----
function drawSeries(){
  const pxLeft=M.l,pxRight=W-M.r;
  const t0v=x.invert(pxLeft).getTime(), t1v=x.invert(pxRight).getTime();
  const idx0=Math.max(0,Math.floor((t0v-time[0])/stepMs));
  const idx1=Math.min(values.length-1,Math.ceil((t1v-time[0])/stepMs));

  ctx.clearRect(0,0,W,H);
  ctx.fillStyle="#fff"; ctx.fillRect(0,0,W,H);

  // no background bands (keep chart clean)

  // threshold lines
  ctx.strokeStyle="#1a9850"; ctx.lineWidth=2;
  [TH.low, TH.high].forEach(val=>{ const yy=y(val); ctx.beginPath(); ctx.moveTo(M.l,yy); ctx.lineTo(W-M.r,yy); ctx.stroke(); });

  // grid
  ctx.strokeStyle="#f0f0f0"; ctx.lineWidth=1;
  for(const t of x.ticks(10)){ const xp=Math.round(x(t)); ctx.beginPath(); ctx.moveTo(xp,M.t); ctx.lineTo(xp,H-M.b); ctx.stroke(); }
  for(const g of y.ticks(6)){ const yp=Math.round(y(g)); ctx.beginPath(); ctx.moveTo(M.l,yp); ctx.lineTo(W-M.r,yp); ctx.stroke(); }

  // dots — batch by color for speed
  const buckets = { vlow:[], low:[], targ:[], high:[], vhigh:[] };
  for (let i=idx0;i<=idx1;i++){
    const px = x(new Date(time[i]));
    const py = y(values[i]);
    const b = bandOf(values[i]);
    buckets[b].push(px,py);
  }
  const r = 1.5;  // dot radius
  for (const k of Object.keys(buckets)){
    const arr = buckets[k]; if (!arr.length) continue;
    ctx.fillStyle = COLORS[k];
    ctx.beginPath();
    for (let j=0;j<arr.length;j+=2){
      const px=arr[j], py=arr[j+1];
      ctx.moveTo(px+r, py);
      ctx.arc(px, py, r, 0, Math.PI*2);
    }
    ctx.fill();
  }

  // axes
  ctx.strokeStyle="#000"; ctx.fillStyle="#000"; ctx.lineWidth=1; ctx.font="10px system-ui";
  ctx.beginPath();ctx.moveTo(M.l,H-M.b+0.5);ctx.lineTo(W-M.r,H-M.b+0.5);ctx.stroke();
  x.ticks(6).forEach(t=>{ const xp=Math.round(x(t));
    ctx.beginPath();ctx.moveTo(xp,H-M.b);ctx.lineTo(xp,H-M.b+5);ctx.stroke();
    ctx.fillText(d3.timeFormat("%b %d")(t), xp-12, H-M.b+16);
  });
  ctx.beginPath();ctx.moveTo(M.l-0.5,M.t);ctx.lineTo(M.l-0.5,H-M.b);ctx.stroke();
  y.ticks(6).forEach(v=>{ const yp=Math.round(y(v));
    ctx.beginPath();ctx.moveTo(M.l-5,yp);ctx.lineTo(M.l,yp);ctx.stroke();
    ctx.fillText(v.toFixed(0), M.l-35, yp+3);
  });
  ctx.fillText(`CGM (${units}) — dots colored by range`, M.l, M.t-6);

  updateTIR(idx0, idx1);
  updateAGP(idx0, idx1);
  updateSummary(idx0, idx1);
}
drawSeries();

// tooltip (nearest sample)
canvas.addEventListener("mousemove",e=>{
  const rect=canvas.getBoundingClientRect();
  const px=e.clientX-rect.left, py=e.clientY-rect.top;
  if(px<M.l||px>W-M.r||py<M.t||py>H-M.b){tip.style.display="none";return;}
  const tval=x.invert(px).getTime();
  const idx=Math.min(values.length-1,Math.max(0,Math.round((tval-time[0])/stepMs)));
  tip.style.display="block"; tip.style.left=px+"px"; tip.style.top=py+"px";
  tip.textContent=`${d3.timeFormat("%Y-%m-%d %H:%M")(new Date(time[idx]))} — ${values[idx].toFixed(1)} ${units}`;
});
canvas.addEventListener("mouseleave",()=>tip.style.display="none");

// drag pan
let isDown=false,startX,startDom;
canvas.addEventListener("mousedown",e=>{isDown=true;startX=e.clientX;startDom=x.domain();});
window.addEventListener("mouseup",()=>isDown=false);
window.addEventListener("mousemove",e=>{
  if(!isDown)return;
  const dx=e.clientX-startX;
  const [d0,d1]=startDom;
  const scale=(d1-d0)/(W-M.l-M.r);
  x.domain([d0-dx*scale,d1-dx*scale]);
  drawSeries();
});

// keyboard zoom W/S and arrow pan
window.addEventListener("keydown",e=>{
  const key = e.key;
  const k = key.toLowerCase();

  // left/right arrow = pan (scroll) in time
  if (key === "ArrowLeft" || key === "ArrowRight") {
    const [d0,d1] = x.domain().map(d=>+d); // ensure numeric ms
    const span = d1 - d0;
    const step = span * 0.25; // pan by 25% of current view
    const dir = key === "ArrowLeft" ? -1 : 1;
    let nd0 = d0 + dir * step;
    let nd1 = d1 + dir * step;
    // clamp to overall data domain
    const min = tDomain[0], max = tDomain[1];
    if (nd0 < min) { nd1 += (min - nd0); nd0 = min; }
    if (nd1 > max) { nd0 -= (nd1 - max); nd1 = max; }
    setDomainViaBrush(nd0, nd1);
    e.preventDefault();
    return;
  }

  // W/S keys = zoom in/out
  if(k!=="w"&&k!=="s") return;
  const factor = k === "w" ? 0.5 : 2;
  const [d0,d1] = x.domain().map(d=>+d); // ensure numeric ms
  const center = (d0 + d1) / 2;
  const newSpan = Math.max(stepMs*20, (d1 - d0) * factor);
  setDomainViaBrush(center - newSpan/2, center + newSpan/2);
  e.preventDefault();
});
// span buttons
const DAY = 24*60*60*1000;
function setSpan(spanMs){
  const [d0,d1] = x.domain().map(d=>+d);
  const center = (d0 + d1) / 2;
  let nd0 = center - spanMs/2;
  let nd1 = center + spanMs/2;
  const min = +tDomain[0], max = +tDomain[1];
  if (nd0 < min) { nd1 += (min - nd0); nd0 = min; }
  if (nd1 > max) { nd0 -= (nd1 - max); nd1 = max; }
  // ensure non-zero span
  if (nd1 - nd0 < stepMs) nd1 = Math.min(max, nd0 + stepMs);
  setDomainViaBrush(nd0, nd1);
}
document.getElementById("span1d").onclick = () => setSpan(1*DAY);
document.getElementById("span7d").onclick = () => setSpan(7*DAY);
document.getElementById("span14d").onclick = () => setSpan(14*DAY);
document.getElementById("span1m").onclick = () => setSpan(30*DAY);
document.getElementById("spanFull").onclick = () => setDomainViaBrush(+tDomain[0], +tDomain[1]);

// helper to keep mini brush in sync with x-domain
function setDomainViaBrush(d0, d1){
  if (typeof miniX !== 'undefined' && typeof brush !== 'undefined' && typeof brushG !== 'undefined') {
    brushG.call(brush.move, [miniX(d0), miniX(d1)]);
  } else {
    x.domain([d0, d1]);
    drawSeries();
  }
}

// mini overview
const miniH=120, miniSvg=d3.select("#mini");
const miniW = (miniSvg.node() && miniSvg.node().getBoundingClientRect().width) || 1200;
const miniX=d3.scaleTime().domain(tDomain).range([M.l,miniW-M.r]);
const miniY=d3.scaleLinear().domain(y.domain()).range([miniH-20,10]);
const stride=Math.max(1,Math.floor(values.length/(miniW-M.l-M.r)));
const miniData=[]; for(let i=0;i<values.length;i+=stride) miniData.push({t:new Date(time[i]),g:values[i]});
miniSvg.append("path").attr("d",d3.line().x(d=>miniX(d.t)).y(d=>miniY(d.g))(miniData))
  .attr("fill","none").attr("stroke","#222");
const brush=d3.brushX().extent([[M.l,10],[miniW-M.r,miniH-20]]).on("brush end",({selection})=>{
  if(!selection)return; const[a,b]=selection.map(miniX.invert); x.domain([+a,+b]); drawSeries();
});
const brushG = miniSvg.append("g").call(brush);
// initial selection: show first third
brushG.call(brush.move,[M.l, M.l + (miniW - M.l - M.r)/3]);

// mini x-axis with months (visible, inside bounds)
const monthFmt = d3.timeFormat("%b '%y");
const miniAxis = d3.axisBottom(miniX)
  .ticks(d3.timeMonth.every(1))
  .tickFormat(monthFmt)
  .tickSizeOuter(0)
  .tickSizeInner(3);
const miniAxisG = miniSvg.append("g").attr("transform", `translate(0,${miniH-8})`).call(miniAxis);
miniAxisG.selectAll("text")
  .attr("font-size", 10)
  .attr("fill", "#444")
  .attr("text-anchor","middle")
  .attr("transform", null)
  .attr("dx", null)
  .attr("dy", null);

// (no month axis in the AGP-initial version)

// ---- vertical TIR (unchanged) ----
function updateTIR(idx0,idx1){
  const n=Math.max(1,idx1-idx0+1);
  let cVL=0,cL=0,cT=0,cH=0,cVH=0;
  for(let i=idx0;i<=idx1;i++){
    const v=values[i];
    if(v<TH.vlow)cVL++; else if(v<TH.low)cL++;
    else if(v<=TH.high)cT++; else if(v<=TH.vhigh)cH++; else cVH++;
  }
  const pct=x=>Math.round(1000*x/n)/10;

  const bands=[
    {name:"Very High", pct:pct(cVH), color:COLORS.vhigh, goal:"<5%"},
    {name:"High",      pct:pct(cH),  color:COLORS.high,  goal:"<25%"},
    {name:"Target",    pct:pct(cT),  color:COLORS.targ,  goal:"≥70%"},
    {name:"Low",       pct:pct(cL),  color:COLORS.low,   goal:"<4%"},
    {name:"Very Low",  pct:pct(cVL), color:COLORS.vlow,  goal:"<1%"}
  ];

  const Wb=300,Hb=300,Mb={t:20,r:80,b:30,l:100};
  const svg=d3.select("#tir").selectAll("svg").data([0]).join("svg")
    .attr("width",Wb).attr("height",Hb);

  svg.selectAll("*").remove();

  const scaleY=d3.scaleLinear().domain([0,100]).range([Hb-Mb.b,Mb.t]);

  // draw stacked bar and collect label targets
  const labels=[];
  let acc=0;
  bands.forEach(b=>{
    const y0=scaleY(acc), y1=scaleY(acc+b.pct);
    svg.append("rect").attr("x",Mb.l).attr("y",y1)
      .attr("width",60).attr("height",y0-y1)
      .attr("fill",b.color);
    labels.push({
      text: `${b.name} ${b.pct}% (goal ${b.goal})`,
      center: (y0+y1)/2,
      color: b.color
    });
    acc+=b.pct;
  });

  // resolve label collisions (top→bottom, then bottom→top)
  const minGap = 14; // px between label baselines
  const yMin = Mb.t + 8;
  const yMax = Hb - Mb.b - 8;
  labels.sort((a,b)=>a.center-b.center);
  // forward pass
  for (let i=0;i<labels.length;i++){
    const prev = labels[i-1];
    let y = Math.max(yMin, Math.min(yMax, labels[i].center));
    if (prev && y < prev.y + minGap) y = prev.y + minGap;
    labels[i].y = y;
  }
  // backward pass
  for (let i=labels.length-2;i>=0;i--){
    const next = labels[i+1];
    if (labels[i].y > next.y - minGap) labels[i].y = next.y - minGap;
    if (labels[i].y < yMin) labels[i].y = yMin;
  }

  // render labels with small connectors, styled per band color
  labels.forEach(l=>{
    svg.append("line").attr("x1",Mb.l+60).attr("x2",Mb.l+66)
      .attr("y1",l.y).attr("y2",l.y).attr("stroke", l.color).attr("opacity",0.8);
    svg.append("text").attr("x",Mb.l+70).attr("y",l.y).attr("dy","0.35em")
      .attr("class","pct").attr("fill", l.color).attr("font-size", 11)
      .text(l.text);
  });

  svg.append("text").attr("x",Mb.l).attr("y",12).text(`Time in Range (current view) — ${units}`);
}

// ---- AGP for selected period ----
function updateAGP(idx0, idx1){
  doUpdateAGP(idx0, idx1);
}

function doUpdateAGP(idx0, idx1){
  const svg = d3.select('#agpSvg');
  svg.selectAll('*').remove();
  const bbox = svg.node().getBoundingClientRect();
  const W = Math.max(360, bbox.width || 600);
  const H = Math.max(220, bbox.height || 260);
  const M = {l:50,r:60,t:20,b:26};

  const dayMs = 24*60*60*1000;
  const samplesPerDay = Math.max(1, Math.round(dayMs/stepMs));
  const byMin = Array.from({length: samplesPerDay}, ()=>[]);
  const daysSet = new Set();

  // collect values by time-of-day bin
  for (let i=idx0;i<=idx1;i++){
    const t = time[i];
    const v = values[i];
    if (!Number.isFinite(v)) continue;
    const d = new Date(t);
    const midnight = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
    daysSet.add(midnight);
    let bin = Math.round((t - midnight) / stepMs);
    if (bin < 0) bin = 0; else if (bin >= samplesPerDay) bin = samplesPerDay-1;
    byMin[bin].push(v);
  }

  // update meta label
  const nDays = daysSet.size || 0;
  const meta = document.getElementById('agpMeta');
  if (meta) meta.textContent = nDays ? `Days used: ${nDays}` : '';

  const q = (arr,p)=>{
    if (!arr.length) return NaN;
    const a = Float64Array.from(arr).sort();
    const pos = (a.length-1)*p; const b = Math.floor(pos); const r = pos-b;
    return a[b] + (a[Math.min(a.length-1,b+1)]-a[b])*(r||0);
  };
  const series = byMin.map((arr,i)=>({
    t:i,
    p05:q(arr,0.05), p25:q(arr,0.25), p50:q(arr,0.50), p75:q(arr,0.75), p95:q(arr,0.95)
  }));

  // if insufficient data, bail
  const ys = series.flatMap(s=>[s.p05,s.p95]).filter(Number.isFinite);
  if (!ys.length){
    svg.append('text').attr('x',M.l).attr('y',H/2).text('Not enough data in selection to compute AGP');
    return;
  }

  const x = d3.scaleLinear().domain([0, samplesPerDay-1]).range([M.l, W-M.r]);
  const y = d3.scaleLinear().domain(d3.extent(ys)).nice().range([H-M.b, M.t]);

  // target band
  svg.append('rect').attr('x',M.l).attr('width',W-M.l-M.r)
    .attr('y', y(TH.high)).attr('height', y(TH.low)-y(TH.high))
    .attr('fill','#E8F6EC');

  const area = (y0,y1)=>d3.area().defined(d=>Number.isFinite(y0(d))&&Number.isFinite(y1(d)))
    .x(d=>x(d.t)).y0(y0).y1(y1);
  const line = d3.line().defined(d=>Number.isFinite(d.p50)).x(d=>x(d.t)).y(d=>y(d.p50));

  svg.append('path').attr('d', area(d=>y(d.p05), d=>y(d.p95))(series))
    .attr('fill','#f4c7a4').attr('opacity',0.55);
  svg.append('path').attr('d', area(d=>y(d.p25), d=>y(d.p75))(series))
    .attr('fill','#fbd699').attr('opacity',0.8);
  svg.append('path').attr('d', line(series)).attr('stroke','#1a9850').attr('fill','none').attr('stroke-width',2);

  // target lines
  svg.append('line').attr('x1',M.l).attr('x2',W-M.r).attr('y1',y(TH.high)).attr('y2',y(TH.high))
    .attr('stroke','#1a9850').attr('stroke-width',2);
  svg.append('line').attr('x1',M.l).attr('x2',W-M.r).attr('y1',y(TH.low)).attr('y2',y(TH.low))
    .attr('stroke','#1a9850').attr('stroke-width',2);

  // x axis: time-of-day labels every 3 hours
  const perHr = 60*60*1000/stepMs;
  const ticks = d3.range(0, 24+1, 3).map(h=>Math.round(h*perHr));
  const fmtHr = h => (h===0||h===24) ? '12am' : (h<12?`${h}am`:(h===12?'12pm':`${h-12}pm`));
  const axis = d3.axisBottom(x).tickValues(ticks).tickFormat(t=>fmtHr(Math.round(t/perHr)));
  svg.append('g').attr('transform',`translate(0,${H-M.b})`).call(axis);
  svg.append('g').attr('transform',`translate(${M.l},0)`).call(d3.axisLeft(y));
}

// ---- Summary metrics for selected period ----
function updateSummary(idx0, idx1){
  const fmtDate = d3.timeFormat("%b %e, %Y");
  const start = new Date(time[idx0]);
  const end = new Date(time[idx1]);
  const periodText = `${fmtDate(start)} – ${fmtDate(end)}`;
  document.getElementById('sumPeriod').textContent = periodText;

  // slice values and filter finite
  const slice = Array.from(values.slice(idx0, idx1+1)).filter(Number.isFinite);
  const expected = Math.max(1, idx1 - idx0 + 1);
  const present = slice.length;
  const activePct = 100 * present / expected;
  document.getElementById('sumActive').textContent = `${activePct.toFixed(1)}%`;

  const mean = d3.mean(slice) ?? NaN;
  const variance = d3.variance(slice) ?? 0;
  const sd = Math.sqrt(variance);
  const gmi = Number.isFinite(mean) ? (3.31 + 0.02392 * toMg(mean)) : NaN;
  const cv = Number.isFinite(mean) && mean !== 0 ? (sd/mean*100) : NaN;

  document.getElementById('sumAvg').textContent = isMmol
    ? `${mean?.toFixed(1)} mmol/L`
    : `${Math.round(mean ?? 0)} mg/dL`;
  document.getElementById('sumGmi').textContent = Number.isFinite(gmi) ? `${gmi.toFixed(1)}%` : '—';
  document.getElementById('sumCv').textContent  = Number.isFinite(cv)  ? `${cv.toFixed(1)}%`  : '—';
}
</script>
</body>
</html>
