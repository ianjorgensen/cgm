<!doctype html>
<html lang="en">
<meta charset="utf-8" />
<title>CGM Viewer — Dots by Range + Vertical TIR</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body { font: 12px system-ui, sans-serif; margin: 16px; color:#111; }
  #chart { border:none; background:#fff; max-width:100%; height:auto; display:block; }
  #mini  { }
  .legend { margin-left:8px; color:#555; }
  .tooltip {
    position:absolute; pointer-events:none; background:#fff; border:1px solid #ddd;
    padding:4px 6px; border-radius:4px; font-size:11px; transform:translate(-50%,-120%);
    z-index: 10000;
  }
  #summary { margin: 42px 0px; padding: 10px 0 !important;}
  #tir { margin-top:20px; text-align:left; }
  #tir svg { display:block; margin:0; overflow: visible; }
  .pct { font-weight:600; font-size:12px; }
  .goal { font-size:10px; fill:#666; }
  .bands-legend { display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; margin-top:6px; color:#444; }
  .sw { width:14px; height:10px; border-radius:2px; display:inline-block; margin-right:4px; }
  .sw-line { width:18px; height:3px; border-radius:2px; display:inline-block; margin-right:4px; background:#1a9850; }
  .muted { color:#777; font-size:12px; }
  .metric { display:flex; justify-content:space-between; padding:8px 10px; border-bottom:1px solid #eee; }
  .metric:last-child { border-bottom:none; }
  .layout { display:grid; grid-template-columns: 320px 1fr; gap:16px; align-items:start; max-width:1200px; }
  .topbar { position: sticky; top: 0; background:#fff; z-index: 10; padding:8px 0; border-bottom:1px solid #eee; }
  .topbar .actions { display:flex; flex-wrap:wrap; align-items:center; gap:10px; }
  .topbar-row { display:flex; gap:12px; align-items:center; }
  .bottombar { position: sticky; bottom: 0; background:#fff; border-top:1px solid #eee; z-index: 10; padding:8px 0; }
  /* reverted: compact summary/bottom bar removed */
  .container { max-width:1200px; margin:0 auto; }
  @media (max-width: 768px){
    .content-row { display:flex !important; flex-direction: column; gap:16px; }
    .content-row > div { flex: none !important; min-width: 0; width: 100%; }
  }
  .footer { font-size:12px; color:#555; text-align:center; margin:12px 0; }
  .mini-help { font-size:12px; color:#555; text-align:center; margin-top:6px; }
  .agp-wrap { position:relative; height:280px; }
  .agp-wrap > svg { position:absolute; inset:0; width:100%; height:100%; }
  .agp-placeholder { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; text-align:center; color:#555; font-size:16px; font-weight:600; }
  .modal-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.35); display:none; align-items:center; justify-content:center; z-index: 20; }
  .modal { background:#fff; border-radius:8px; padding:14px 16px; width:min(640px, 92vw); box-shadow:0 10px 30px rgba(0,0,0,0.2); }
  .modal h3 { margin:0 0 8px; font-size:14px; }
  .modal ul { margin:6px 0; padding-left:16px; }
  .kbd { display:inline-block; padding:2px 6px; border:1px solid #ccc; border-radius:4px; background:#f9f9f9; font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size:11px; }
  /* Make the mini brush selection more visible */
  #mini .selection { fill: #f7c6d9; fill-opacity: 0.45; stroke: none; }
  #mini .handle { stroke: none; fill: #f7c6d9; fill-opacity: 0.30; }
  /* Match brush style on full-range chart */
  /* (reverted) no custom brush styling on full-range */
</style>

<body>
  <!-- sticky mini picker at bottom (moved from top) -->

  <div class="container">
    <!-- Two-column layout: Left (1/4) TIR+Summary, Right (3/4) AGP+Chart -->
    <div class="content-row" style="display:flex; gap:16px; align-items:flex-start; margin-top:12px;">
    <!-- Left column (1/4) -->
    <div style="flex:1 1 0; min-width:0;">
      <div id="summary" style="border:1px solid #e6e6e6; border-radius:8px; padding:10px; background:#fff;">
        <div class="metric"><div><b>Report Period</b></div><div id="sumPeriod"></div></div>
        <div class="metric"><div><b>Time CGM Active</b></div><div id="sumActive"></div></div>
        <div class="metric"><div><b>Average Glucose</b><div class="muted">Goal: &lt;154 mg/dL (8.6 mmol/L)</div></div><div id="sumAvg"></div></div>
        <div class="metric"><div><b>Glucose Management Indicator (GMI)</b><div class="muted">Goal: &lt;7%</div></div><div id="sumGmi"></div></div>
        <div class="metric"><div><b>Glucose Variability (CV)</b><div class="muted">Goal: ≤36%</div></div><div id="sumCv"></div></div>
      </div>
      <div id="tir" style="margin-top:16px;"></div>
    </div>

    <!-- Right column (3/4) -->
    <div style="flex:3 1 0; min-width:0;">
      <div id="agpSection" class="agp-wrap">
        <svg id="agpSvg"></svg>
        <div id="agpMsg" class="agp-placeholder" style="display:none;">Not enough data available to compute AGP profile</div>
      </div>

      <div id="chartWrap" style="position:relative;">
        <canvas id="chart" width="1200" height="260"></canvas>
        <div id="tip" class="tooltip" style="display:none;"></div>
        <div id="chartMsg" class="agp-placeholder" style="display:none; height:260px;">Too much data to display on daily view</div>
      </div>
      <div id="bandsLegend" class="bands-legend" style="margin-top:8px;"></div>
    </div>
    </div>

    <!-- Footer row: AGP title + days used -->
    <div class="footer" style="font-weight:600; display:flex; gap:10px; justify-content:center; align-items:baseline;">
      <span>AGP — Selected Period</span>
      <span id="agpMeta" style="font-weight:400; color:#555; font-size:12px;"></span>
    </div>
  </div>

  <!-- Keyboard Shortcuts Modal -->
  <div id="helpOverlay" class="modal-overlay">
    <div class="modal">
      <h3>Keyboard Shortcuts</h3>
      <ul>
        <li><span class="kbd">Drag</span>: pan the main chart</li>
        <li><span class="kbd">W</span>/<span class="kbd">S</span>: zoom in/out</li>
        <li><span class="kbd">←</span>/<span class="kbd">→</span>: pan by 25% window</li>
        <li><span class="kbd">Shift</span> + <span class="kbd">←</span>/<span class="kbd">→</span>: jump a full window</li>
        <li><span class="kbd">1</span>/<span class="kbd">2</span>/<span class="kbd">3</span>/<span class="kbd">4</span>/<span class="kbd">5</span>/<span class="kbd">6</span>: set window to 1d / 7d / 14d / 1m / 3m / Full (up to 1 year)</li>
        <li><span class="kbd">H</span>: set URL hash to current view (shareable)</li>
        <li><span class="kbd">Esc</span>: close dialog or clear URL hash</li>
      </ul>
      <div style="text-align:right; margin-top:8px;"><button id="closeHelp">Close</button></div>
    </div>
  </div>
  <!-- Sticky bottom bar: mini overview time picker -->
  <div class="bottombar">
    <div class="container">
      <svg id="mini" height="140" style="width:100%;"></svg>
      <svg id="fullRange" height="100" style="width:100%; margin-top:6px;"></svg>
      <div class="mini-help"><span class="kbd">?</span> to view keyboard shortcuts</div>
    </div>
  </div>
  <!-- Tooltip for footer charts (fixed positioning for global placement) -->
  <div id="tipFull" class="tooltip" style="display:none; position:fixed;"></div>

<script type="module">
import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
import { units, t0, stepMs, glucose } from "./cgm_data_test.js";

const M={t:20,r:50,b:30,l:50};
const canvas=document.getElementById("chart");
const ctx=canvas.getContext("2d",{alpha:false});
// responsive canvas width so y-axes align with AGP
function getCanvasWidth(){ return Math.max(300, Math.floor(canvas.getBoundingClientRect().width||1200)); }
canvas.width = getCanvasWidth();
let W = canvas.width, H = 260; // match or be lower than AGP height
canvas.height = H;
const tip=document.getElementById("tip");

const tStart=new Date(t0).getTime();
const time=Float64Array.from({length:glucose.length},(_,i)=>tStart+i*stepMs);
const values=Float64Array.from(glucose);
const tDomain=[time[0],time[time.length-1]];
const yDomain=d3.extent(Array.from(values).filter(v=>Number.isFinite(v) && v>=0)) || [0,10];

const x=d3.scaleTime().domain(tDomain).range([M.l,W-M.r]);
const y=d3.scaleLinear().domain(yDomain).nice().range([H-M.b,M.t]);

const isMmol = /mmol/i.test(units);
const TH = isMmol
  ? { vlow:3.0, low:3.9, high:10.0, vhigh:13.9, label:"mmol/L" }
  : { vlow:54,  low:70,  high:180,  vhigh:250,  label:"mg/dL" };
const toMg = v => isMmol ? v*18 : v;

// colors + helpers
const COLORS = { vlow:"#b30000", low:"#e34a33", targ:"#1a9850", high:"#fdae61", vhigh:"#f46d43" };
function bandOf(v){
  if (v < TH.vlow) return "vlow";
  if (v < TH.low)  return "low";
  if (v <= TH.high) return "targ";
  if (v <= TH.vhigh) return "high";
  return "vhigh";
}
function renderLegendInto(id){
  const box = document.getElementById(id);
  if (!box) return;
  box.innerHTML = "";
  const legend = [
    {c:COLORS.vlow,  t:`Very Low < ${TH.vlow} ${units}`},
    {c:COLORS.low,   t:`Low ${isMmol?'3.0–3.9':'54–70'} ${units}`},
    {c:COLORS.targ,  t:`Target ${isMmol?'3.9–10.0':'70–180'} ${units}`},
    {c:COLORS.high,  t:`High ${isMmol?'10.0–13.9':'180–250'} ${units}`},
    {c:COLORS.vhigh, t:`Very High > ${TH.vhigh} ${units}`}
  ];
  legend.forEach(d=>{
    const span = document.createElement("span");
    const sw = document.createElement("span"); sw.className="sw"; sw.style.background=d.c;
    span.appendChild(sw); span.appendChild(document.createTextNode(d.t));
    box.appendChild(span);
  });
}
function renderLegends(){
  renderLegendInto("bandsLegend");
  renderLegendInto("agpPctLegend");
}
renderLegends();

// ---- helpers: ordinal date formatters ----
const timeHM = d3.timeFormat("%H:%M");
const monthShort = d3.timeFormat("%b");
function ordinal(n){
  const j=n%10, k=n%100;
  if(j===1 && k!==11) return `${n}st`;
  if(j===2 && k!==12) return `${n}nd`;
  if(j===3 && k!==13) return `${n}rd`;
  return `${n}th`;
}
function fmtAxisDate(d){ return `${monthShort(d)} ${ordinal(d.getDate())}`; }
function fmtTooltip(d){ return `${monthShort(d)} ${ordinal(d.getDate())} ${d.getFullYear()} - ${timeHM(d)}`; }

// ---- draw series (as colored dots) ----
function drawSeries(){
  const pxLeft=M.l,pxRight=W-M.r;
  const t0v=x.invert(pxLeft).getTime(), t1v=x.invert(pxRight).getTime();
  const idx0=Math.max(0,Math.floor((t0v-time[0])/stepMs));
  const idx1=Math.min(values.length-1,Math.ceil((t1v-time[0])/stepMs));

  // Toggle visibility when selection is too wide (>90 days)
  const dayMs = 24*60*60*1000;
  const tooWide = (t1v - t0v) > 90*dayMs;
  const chartEl = document.getElementById('chart');
  const chartMsg = document.getElementById('chartMsg');
  if (chartMsg) chartMsg.style.display = tooWide ? 'flex' : 'none';
  if (chartEl) chartEl.style.visibility = tooWide ? 'hidden' : 'visible';

  ctx.clearRect(0,0,W,H);
  ctx.fillStyle="#fff"; ctx.fillRect(0,0,W,H);

  if (tooWide){
    // Still update side panels/AGP/summary based on current idx, but skip drawing the chart
    updateTIR(idx0, idx1);
    const showAGP = updateAGPVisibility(idx0, idx1);
    if (showAGP) updateAGP(idx0, idx1);
    updateSummary(idx0, idx1);
    return;
  }

  // no background bands (keep chart clean)

  // threshold lines
  ctx.strokeStyle="#1a9850"; ctx.lineWidth=2;
  [TH.low, TH.high].forEach(val=>{ const yy=y(val); ctx.beginPath(); ctx.moveTo(M.l,yy); ctx.lineTo(W-M.r,yy); ctx.stroke(); });

  // grid
  ctx.strokeStyle="#f0f0f0"; ctx.lineWidth=1;
  for(const t of x.ticks(10)){ const xp=Math.round(x(t)); ctx.beginPath(); ctx.moveTo(xp,M.t); ctx.lineTo(xp,H-M.b); ctx.stroke(); }
  for(const g of y.ticks(6)){ const yp=Math.round(y(g)); ctx.beginPath(); ctx.moveTo(M.l,yp); ctx.lineTo(W-M.r,yp); ctx.stroke(); }

  // dots — batch by color for speed (skip -1 / missing)
  const buckets = { vlow:[], low:[], targ:[], high:[], vhigh:[] };
  for (let i=idx0;i<=idx1;i++){
    const v = values[i]; if (!(Number.isFinite(v) && v>=0)) continue;
    const px = x(new Date(time[i]));
    const py = y(v);
    const b = bandOf(v);
    buckets[b].push(px,py);
  }
  const r = 1.5;  // dot radius
  for (const k of Object.keys(buckets)){
    const arr = buckets[k]; if (!arr.length) continue;
    ctx.fillStyle = COLORS[k];
    ctx.beginPath();
    for (let j=0;j<arr.length;j+=2){
      const px=arr[j], py=arr[j+1];
      ctx.moveTo(px+r, py);
      ctx.arc(px, py, r, 0, Math.PI*2);
    }
    ctx.fill();
  }

  // axes
  ctx.strokeStyle="#000"; ctx.fillStyle="#000"; ctx.lineWidth=1; ctx.font="10px system-ui";
  ctx.beginPath();ctx.moveTo(M.l,H-M.b+0.5);ctx.lineTo(W-M.r,H-M.b+0.5);ctx.stroke();
  // dynamic x-axis tick formatting based on span
  const [xd0, xd1] = x.domain();
  const spanMs = (+xd1) - (+xd0);
  const oneDay = 24*60*60*1000;
  let xticks, fmtTick, xOffset;
  if (spanMs <= oneDay*2) {
    const every = spanMs <= oneDay ? 2 : 3; // every 2h if <=1d else every 3h
    xticks = x.ticks(d3.timeHour.every(every));
    fmtTick = timeHM; // HH:MM
    xOffset = -12;
  } else {
    xticks = x.ticks(6);
    fmtTick = fmtAxisDate; // Mon 1st
    xOffset = -18;
  }
  xticks.forEach(t=>{ const xp=Math.round(x(t));
    ctx.beginPath();ctx.moveTo(xp,H-M.b);ctx.lineTo(xp,H-M.b+5);ctx.stroke();
    ctx.fillText(fmtTick(t), xp+xOffset, H-M.b+16);
  });
  ctx.beginPath();ctx.moveTo(M.l-0.5,M.t);ctx.lineTo(M.l-0.5,H-M.b);ctx.stroke();
  y.ticks(6).forEach(v=>{ const yp=Math.round(y(v));
    ctx.beginPath();ctx.moveTo(M.l-5,yp);ctx.lineTo(M.l,yp);ctx.stroke();
    ctx.fillText(v.toFixed(0), M.l-35, yp+3);
  });
  // removed chart title text for a cleaner look

  updateTIR(idx0, idx1);
  const showAGP = updateAGPVisibility(idx0, idx1);
  if (showAGP) updateAGP(idx0, idx1);
  updateSummary(idx0, idx1);
}
drawSeries();

// keep canvas in sync with container width
function handleResize(){
  const w = getCanvasWidth();
  if (w !== W){
    canvas.width = w; W = w;
    x.range([M.l, W-M.r]);
    drawSeries();
    // rerender footer sparkline to fit new width
    renderFullRange();
  }
}
window.addEventListener('resize', handleResize);

// tooltip (nearest sample)
canvas.addEventListener("mousemove",e=>{
  const rect=canvas.getBoundingClientRect();
  const px=e.clientX-rect.left, py=e.clientY-rect.top;
  if(px<M.l||px>W-M.r||py<M.t||py>H-M.b){tip.style.display="none";return;}
  const tval=x.invert(px).getTime();
  const idx=Math.min(values.length-1,Math.max(0,Math.round((tval-time[0])/stepMs)));
  const v = values[idx];
  if (!(Number.isFinite(v) && v>=0)){ tip.style.display="none"; return; }
  tip.style.display="block"; tip.style.left=px+"px"; tip.style.top=py+"px";
  const td = new Date(time[idx]);
  tip.textContent=`${fmtTooltip(td)} — ${v.toFixed(1)} ${units}`;
});
canvas.addEventListener("mouseleave",()=>tip.style.display="none");

// drag pan (sync mini selection)
let isDown=false,startX,startDom;
canvas.addEventListener("mousedown",e=>{isDown=true;startX=e.clientX;startDom=x.domain().map(d=>+d);});
window.addEventListener("mouseup",()=>isDown=false);
window.addEventListener("mousemove",e=>{
  if(!isDown)return;
  const dx=e.clientX-startX;
  const [d0,d1]=startDom; // numeric ms
  const scale=(d1-d0)/(W-M.l-M.r);
  let nd0=d0-dx*scale, nd1=d1-dx*scale;
  // clamp to data domain
  const min=+tDomain[0], max=+tDomain[1];
  if (nd0 < min) { nd1 += (min - nd0); nd0 = min; }
  if (nd1 > max) { nd0 -= (nd1 - max); nd1 = max; }
  setDomainViaBrush(nd0, nd1);
});

// wheel scroll on chart: pan, with Ctrl+wheel for zoom
canvas.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const [d0,d1] = x.domain().map(d=>+d);
  const span = d1 - d0;
  if (e.ctrlKey) {
    // zoom using wheel: negative deltaY zoom in
    const k = Math.exp(e.deltaY * 0.001);
    const center = (d0 + d1) / 2;
    const minSpan = 24*60*60*1000; // 1 day
    const maxSpan = 365*24*60*60*1000; // 1 year
    const total = (+tDomain[1]) - (+tDomain[0]);
    const newSpan = Math.min(Math.max(minSpan, span * k), Math.min(maxSpan, total));
    setDomainViaBrush(center - newSpan/2, center + newSpan/2);
  } else {
    // pan proportional to deltaY (trackpad or wheel)
    const step = span * (e.deltaY * 0.001); // ~0.1 span per 100px scroll
    let nd0 = d0 + step, nd1 = d1 + step;
    const min=+tDomain[0], max=+tDomain[1];
    if (nd0 < min) { nd1 += (min - nd0); nd0 = min; }
    if (nd1 > max) { nd0 -= (nd1 - max); nd1 = max; }
    setDomainViaBrush(nd0, nd1);
  }
}, { passive:false });

// keyboard zoom W/S and arrow pan
window.addEventListener("keydown",e=>{
  const key = e.key;
  const k = key.toLowerCase();

  // '?' opens shortcuts modal
  if (key === '?' || (k === '/' && e.shiftKey)){
    const ov = document.getElementById('helpOverlay');
    if (ov) ov.style.display = 'flex';
    e.preventDefault();
    return;
  }

  // 'h' sets the URL hash to the current view (shareable link)
  if (k === 'h' && !e.metaKey && !e.ctrlKey && !e.altKey){
    const [d0,d1] = x.domain().map(d=>+d);
    updateHash(d0, d1);
    e.preventDefault();
    return;
  }

  // Numeric shortcuts for window spans: 1d,7d,14d,1m,Full
  if (!e.metaKey && !e.ctrlKey && !e.altKey){
    const DAY = 24*60*60*1000;
    if (key === '1'){ setSpan(1*DAY); e.preventDefault(); return; }
    if (key === '2'){ setSpan(7*DAY); e.preventDefault(); return; }
    if (key === '3'){ setSpan(14*DAY); e.preventDefault(); return; }
    if (key === '4'){ setSpan(30*DAY); e.preventDefault(); return; }
    if (key === '5'){ setSpan(90*DAY); e.preventDefault(); return; }
    if (key === '6'){ setDomainViaBrush(+tDomain[0], +tDomain[1]); e.preventDefault(); return; }
  }

  // Shift + Arrow or '<' '>' keys = jump by full window
  if (key === '>' || key === '<' || (e.shiftKey && (key === 'ArrowRight' || key === 'ArrowLeft'))) {
    const [d0,d1] = x.domain().map(d=>+d);
    const span = d1 - d0;
    let nd0, nd1;
    if (key === '>' || key === 'ArrowRight') {
      // jump right: new start = old end
      nd0 = d1; nd1 = d1 + span;
    } else {
      // jump left: new end = old start
      nd0 = d0 - span; nd1 = d0;
    }
    const min = +tDomain[0], max = +tDomain[1];
    if (nd0 < min) { nd1 += (min - nd0); nd0 = min; }
    if (nd1 > max) { nd0 -= (nd1 - max); nd1 = max; }
    setDomainViaBrush(nd0, nd1);
    e.preventDefault();
    return;
  }

  // left/right arrow = pan (scroll) in time
  if (key === "ArrowLeft" || key === "ArrowRight") {
    const [d0,d1] = x.domain().map(d=>+d); // ensure numeric ms
    const span = d1 - d0;
    const step = span * 0.25; // pan by 25% of current view
    const dir = key === "ArrowLeft" ? -1 : 1;
    let nd0 = d0 + dir * step;
    let nd1 = d1 + dir * step;
    // clamp to overall data domain
    const min = tDomain[0], max = tDomain[1];
    if (nd0 < min) { nd1 += (min - nd0); nd0 = min; }
    if (nd1 > max) { nd0 -= (nd1 - max); nd1 = max; }
    setDomainViaBrush(nd0, nd1);
    e.preventDefault();
    return;
  }

  // W/S keys = zoom in/out
  if(k!=="w"&&k!=="s") return;
  const factor = k === "w" ? 0.5 : 2;
  const [d0,d1] = x.domain().map(d=>+d); // ensure numeric ms
  const center = (d0 + d1) / 2;
  const minSpan = 24*60*60*1000; // 1 day
  const maxSpan = 365*24*60*60*1000; // 1 year
  const total = (+tDomain[1]) - (+tDomain[0]);
  const newSpan = Math.min(Math.max(minSpan, (d1 - d0) * factor), Math.min(maxSpan, total));
  setDomainViaBrush(center - newSpan/2, center + newSpan/2);
  e.preventDefault();
});
// span buttons
const DAY = 24*60*60*1000;
function setSpan(spanMs){
  const [d0,d1] = x.domain().map(d=>+d);
  const center = (d0 + d1) / 2;
  let nd0 = center - spanMs/2;
  let nd1 = center + spanMs/2;
  const min = +tDomain[0], max = +tDomain[1];
  if (nd0 < min) { nd1 += (min - nd0); nd0 = min; }
  if (nd1 > max) { nd0 -= (nd1 - max); nd1 = max; }
  // ensure non-zero span
  if (nd1 - nd0 < stepMs) nd1 = Math.min(max, nd0 + stepMs);
  setDomainViaBrush(nd0, nd1);
}
const btn1 = document.getElementById("span1d"); if (btn1) btn1.onclick = () => setSpan(1*DAY);
const btn7 = document.getElementById("span7d"); if (btn7) btn7.onclick = () => setSpan(7*DAY);
const btn14 = document.getElementById("span14d"); if (btn14) btn14.onclick = () => setSpan(14*DAY);
const btn1m = document.getElementById("span1m"); if (btn1m) btn1m.onclick = () => setSpan(30*DAY);
const btnFull = document.getElementById("spanFull"); if (btnFull) btnFull.onclick = () => setDomainViaBrush(+tDomain[0], +tDomain[1]);

// shortcuts modal open/close
const openHelp = document.getElementById('openHelp');
if (openHelp) openHelp.addEventListener('click', (e)=>{
  e.preventDefault(); const ov=document.getElementById('helpOverlay'); if(ov) ov.style.display='flex';
});
document.getElementById('closeHelp').addEventListener('click', ()=>{
  const ov=document.getElementById('helpOverlay'); if(ov) ov.style.display='none';
});
document.getElementById('helpOverlay').addEventListener('click', (e)=>{
  if (e.target.id === 'helpOverlay'){ e.currentTarget.style.display='none'; }
});
window.addEventListener('keydown', (e)=>{
  if (e.key === 'Escape'){
    const ov=document.getElementById('helpOverlay');
    if (ov && ov.style.display==='flex') { ov.style.display='none'; e.preventDefault(); return; }
    // Clear the URL hash
    if (location.hash){ history.replaceState(null, '', location.pathname + location.search); e.preventDefault(); }
  }
});

// URL hash helpers for sharing current selection
function updateHash(d0, d1){
  const s = `t=${Math.round(d0)},${Math.round(d1)}`;
  const target = `#${s}`;
  if (location.hash !== target){
    history.replaceState(null, '', target);
  }
}

// helper to keep mini brush in sync with x-domain (no automatic hash updates)
function setDomainViaBrush(d0, d1){
  // clamp to data bounds and ensure >= 1 step span
  const min = +tDomain[0], max = +tDomain[1];
  if (d0 < min) { d1 += (min - d0); d0 = min; }
  if (d1 > max) { d0 -= (d1 - max); d1 = max; }
  d0 = Math.max(min, Math.min(max, d0));
  d1 = Math.max(min, Math.min(max, d1));
  const minSpan = 24*60*60*1000; // 1 day
  const maxSpan = 365*24*60*60*1000; // 1 year
  let span = d1 - d0;
  if (span < minSpan){
    const center = (d0 + d1) / 2;
    d0 = Math.max(min, Math.min(max - minSpan, center - minSpan/2));
    d1 = Math.min(max, d0 + minSpan);
    span = d1 - d0;
  }
  if (span > maxSpan){
    const center = (d0 + d1) / 2;
    d0 = Math.max(min, Math.min(max - maxSpan, center - maxSpan/2));
    d1 = Math.min(max, d0 + maxSpan);
  }
  if (typeof miniX !== 'undefined' && typeof brush !== 'undefined' && typeof brushG !== 'undefined') {
    brushG.call(brush.move, [miniX(d0), miniX(d1)]);
  } else {
    x.domain([d0, d1]);
    drawSeries();
  }
}

// mini overview
const miniH=120, miniSvg=d3.select("#mini");
const miniW = (miniSvg.node() && miniSvg.node().getBoundingClientRect().width) || 1200;
const miniX=d3.scaleTime().domain(tDomain).range([M.l,miniW-M.r]);
// Show percent TIR like fullRange: 0..100
const miniY=d3.scaleLinear().domain([0,100]).range([miniH-20,10]);
// Build per-day percent TIR across full dataset (same as fullRange)
const dayMs_m = 24*60*60*1000;
const byDayMini = new Map();
for (let i=0;i<values.length;i++){
  const v=values[i]; if(!(Number.isFinite(v)&&v>=0)) continue;
  const d=new Date(time[i]); const ds=new Date(d.getFullYear(),d.getMonth(),d.getDate()).getTime();
  let rec=byDayMini.get(ds); if(!rec){ rec={valid:0,targ:0}; byDayMini.set(ds,rec); }
  rec.valid++; if(v>=TH.low && v<=TH.high) rec.targ++;
}
const samplesPerDay_m = Math.round(dayMs_m/stepMs);
const daysMini = Array.from(byDayMini.entries()).sort((a,b)=>a[0]-b[0]).map(([t,rec])=>{
  const active = rec.valid / samplesPerDay_m * 100;
  const pct = rec.valid ? (rec.targ/rec.valid*100) : NaN;
  return { t:new Date(t + dayMs_m/2), pct: active>=50 ? pct : NaN };
});
miniSvg.append("path")
  .attr("d", d3.line().defined(d=>Number.isFinite(d.pct)).x(d=>miniX(d.t)).y(d=>miniY(d.pct))(daysMini))
  .attr("fill","none").attr("stroke",COLORS.targ).attr("stroke-width",1.2);
let suppressMiniBrush = false;
const brush=d3.brushX().handleSize(3).extent([[M.l,10],[miniW-M.r,miniH-20]]).on("brush end",(ev)=>{
  const {selection, sourceEvent} = ev;
  const dayMs = 24*60*60*1000;
  if(!selection){
    // Treat as click-to-day when no drag selection exists
    if (!sourceEvent) return;
    const [mx,my] = d3.pointer(sourceEvent, miniSvg.node());
    if (mx < M.l || mx > (miniW - M.r) || my < 10 || my > (miniH - 20)) return;
    const t = miniX.invert(mx);
    const d = new Date(t);
    const dayStart = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
    setDomainViaBrush(dayStart, dayStart + dayMs);
    return;
  }
  let [a,b]=selection.map(miniX.invert);
  const min = +tDomain[0], max = +tDomain[1];
  const minSpan = 24*60*60*1000; // 1 day
  const maxSpan = 365*24*60*60*1000; // 1 year
  let d0 = +a, d1 = +b;
  let span = d1 - d0;
  if (span < minSpan){
    const center = (d0 + d1) / 2;
    d0 = Math.max(min, Math.min(max - minSpan, center - minSpan/2));
    d1 = Math.min(max, d0 + minSpan);
    if (!suppressMiniBrush){
      suppressMiniBrush = true;
      brushG.call(brush.move, [miniX(d0), miniX(d1)]);
      suppressMiniBrush = false;
    }
    x.domain([d0,d1]); drawSeries();
    return;
  }
  if (span > maxSpan){
    const center = (d0 + d1) / 2;
    d0 = Math.max(min, Math.min(max - maxSpan, center - maxSpan/2));
    d1 = Math.min(max, d0 + maxSpan);
    if (!suppressMiniBrush){
      suppressMiniBrush = true;
      brushG.call(brush.move, [miniX(d0), miniX(d1)]);
      suppressMiniBrush = false;
    }
    x.domain([d0,d1]); drawSeries();
    return;
  }
  if (!suppressMiniBrush){ x.domain([d0,d1]); drawSeries(); }
});
const brushG = miniSvg.append("g").call(brush);

// Click on mini to jump to that day (keep brush drag for range selection)
(function enableMiniClick(){
  const dayMs = 24*60*60*1000;
  let down = null;
  const overlay = brushG.select('.overlay');
  function onDown(event){ const [mx,my]=d3.pointer(event, miniSvg.node()); down={x:mx,y:my}; }
  function onUp(event){
    if(!down){ return; }
    const [mx,my]=d3.pointer(event, miniSvg.node());
    const move = Math.abs(mx-down.x)+Math.abs(my-down.y);
    down=null;
    // treat as click if minimal movement
    if (move < 4){
      if (mx < M.l || mx > (miniW - M.r) || my < 10 || my > (miniH - 20)) return;
      const t = miniX.invert(mx);
      const d = new Date(t);
      const dayStart = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
      // defer to run after brush "end" handlers
      setTimeout(()=> setDomainViaBrush(dayStart, dayStart + dayMs), 0);
    }
  }
  overlay.on('mousedown', onDown).on('mouseup', onUp);
})();

// initialize selection from URL hash (t=startMs,endMs) or default to last 14 days
function applyHashSelection(){
  const m = (location.hash||'').match(/t=(\d+),(\d+)/);
  if (m){
    let d0 = +m[1], d1 = +m[2];
    const min=+tDomain[0], max=+tDomain[1];
    if (isNaN(d0)||isNaN(d1)||d0>=d1){ d0 = Math.max(min, max-14*24*60*60*1000); d1 = max; }
    d0 = Math.max(min, Math.min(max, d0));
    d1 = Math.max(min, Math.min(max, d1));
    setDomainViaBrush(d0, d1);
  } else {
    const max = +tDomain[1];
    const min = +tDomain[0];
    const d0 = Math.max(min, max - 14*24*60*60*1000);
    const d1 = max;
    setDomainViaBrush(d0, d1);
  }
}
applyHashSelection();
window.addEventListener('hashchange', applyHashSelection);

// mini x-axis with adaptive month ticks; show year on January
function renderMiniAxis(){
  miniSvg.selectAll('.mini-axis').remove();
  const start = new Date(tDomain[0]);
  const end = new Date(tDomain[1]);
  const months = d3.timeMonths(d3.timeMonth.floor(start), end);
  const fmtM = d3.timeFormat('%b');
  const fmtY = d3.timeFormat("'%y");
  // Determine how many labels fit (~40px per label)
  const bbox = miniSvg.node().getBoundingClientRect();
  const avail = Math.max(60, (bbox.width || (W - M.l - M.r)) - (M.l + M.r));
  const maxTicks = Math.max(2, Math.floor(avail / 40));
  const step = Math.max(1, Math.ceil(months.length / maxTicks));
  const tickMonths = months.filter((_,i)=> i % step === 0);
  const axis = d3.axisBottom(miniX)
    .tickValues(tickMonths)
    .tickFormat(d=> d.getMonth()===0 ? `${fmtM(d)} ${fmtY(d)}` : fmtM(d))
    .tickPadding(6)
    .tickSizeOuter(0)
    .tickSizeInner(3);
  const g = miniSvg.append('g').attr('class','mini-axis').attr('transform', `translate(0,${miniH-8})`).call(axis);
  g.selectAll('text').attr('font-size',10).attr('fill','#444').attr('text-anchor','middle').attr('dy','0.6em');
}
renderMiniAxis();

// Mini hover tooltip (date + value)
(function addMiniHover(){
  const tipEl = document.getElementById('tipFull'); if (!tipEl) return;
  const bisect = d3.bisector(d=>d.t).left;
  function onMove(event){
    const [mx,my] = d3.pointer(event, miniSvg.node());
    const withinX = mx >= M.l && mx <= (miniW - M.r);
    const withinY = my >= 10 && my <= (miniH - 20);
    if (!withinX || !withinY){ tipEl.style.display='none'; return; }
    const tHover = miniX.invert(mx);
    let i = bisect(daysMini, tHover);
    i = Math.max(0, Math.min(daysMini.length-1, i));
    let cand = daysMini[i];
    if (i>0 && Math.abs(+daysMini[i-1].t - +tHover) < Math.abs(+cand.t - +tHover)) cand = daysMini[i-1];
    const rect = miniSvg.node().getBoundingClientRect();
    tipEl.style.display = 'block';
    tipEl.style.left = (rect.left + mx) + 'px';
    tipEl.style.top  = (rect.top + my - 10) + 'px';
    const d = cand.t;
    const label = `${monthShort(d)} ${ordinal(d.getDate())} ${d.getFullYear()}`;
    tipEl.textContent = Number.isFinite(cand.pct) ? `${label} — ${cand.pct.toFixed(1)}% TIR` : `${label} — not enough data`;
  }
  function onLeave(){ tipEl.style.display='none'; }
  // attach to brush overlay/selection for reliable events
  miniSvg.selectAll('.overlay, .selection')
    .on('mousemove', onMove)
    .on('mouseleave', onLeave);
  // also attach to svg root as a fallback
  miniSvg.on('mousemove', onMove).on('mouseleave', onLeave);
})();

// (no month axis in the AGP-initial version)

// Full-range sparkline (below mini, full dataset)
function renderFullRange(){
  const svg = d3.select('#fullRange');
  if (svg.empty()) return;
  svg.selectAll('*').remove();
  const bbox = svg.node().getBoundingClientRect();
  const Wf = Math.max(360, bbox.width || 600);
  const Hf = Math.max(80, bbox.height || 100);
  const m = {l:M.l, r:M.r, t:6, b:14};
  const xF = d3.scaleTime().domain(tDomain).range([m.l, Wf-m.r]);
  const yF = d3.scaleLinear().domain([0,100]).range([Hf-m.b, m.t]);

  // Build per-day percentage of time in target over the FULL dataset
  const dayMs = 24*60*60*1000;
  const byDay = new Map(); // dayStart -> {valid,targ}
  for (let i=0;i<values.length;i++){
    const v = values[i]; if (!(Number.isFinite(v) && v>=0)) continue;
    const d = new Date(time[i]);
    const dayStart = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
    let rec = byDay.get(dayStart); if (!rec){ rec = {valid:0,targ:0}; byDay.set(dayStart, rec); }
    rec.valid++; if (v >= TH.low && v <= TH.high) rec.targ++;
  }
  const samplesPerDay = Math.round(dayMs/stepMs);
  const days = Array.from(byDay.entries()).sort((a,b)=>a[0]-b[0]).map(([t,rec])=>{
    const active = rec.valid / samplesPerDay * 100;
    const pct = rec.valid ? (rec.targ/rec.valid*100) : NaN;
    // Hide days with too little data (<50% active)
    return { t: new Date(t + dayMs/2), pct: active >= 50 ? pct : NaN };
  });
  const line = d3.line().defined(d=>Number.isFinite(d.pct)).x(d=>xF(d.t)).y(d=>yF(d.pct));
  svg.append('path').attr('d', line(days)).attr('fill','none').attr('stroke', COLORS.targ).attr('stroke-width',1.2);
  // optional baseline
  svg.append('line').attr('x1',m.l).attr('x2',Wf-m.r).attr('y1',Hf-m.b+0.5).attr('y2',Hf-m.b+0.5)
    .attr('stroke','#ddd');
  // y-axis: 0%, 50%, 100%
  const yAxis = d3.axisLeft(yF).tickValues([0,50,100]).tickFormat(d=>d+"%");
  svg.append('g').attr('transform',`translate(${m.l},0)`).call(yAxis)
    .selectAll('text').attr('font-size',10);

  // Hover tooltip (dedicated fixed tooltip)
  const tipEl = document.getElementById('tipFull');
  const bisect = d3.bisector(d=>d.t).left;
  svg.append('rect')
    .attr('x', m.l).attr('y', m.t)
    .attr('width', Wf - m.l - m.r)
    .attr('height', Hf - m.t - m.b)
    .attr('fill', 'transparent')
    .style('cursor','pointer')
    .on('mousemove', (event)=>{
      const [mx, my] = d3.pointer(event, svg.node());
      const tHover = xF.invert(mx);
      let i = bisect(days, tHover);
      i = Math.max(0, Math.min(days.length-1, i));
      // choose closest between i and i-1
      let cand = days[i];
      if (i>0 && Math.abs(+days[i-1].t - +tHover) < Math.abs(+cand.t - +tHover)) cand = days[i-1];
      const rect = svg.node().getBoundingClientRect();
      tipEl.style.display = 'block';
      tipEl.style.left = (rect.left + mx) + 'px';
      tipEl.style.top  = (rect.top + my - 10) + 'px';
      // Match chart date style (ordinal day + year)
      const label = `${monthShort(cand.t)} ${ordinal(cand.t.getDate())} ${cand.t.getFullYear()}`;
      const text = Number.isFinite(cand?.pct)
        ? `${label} — ${cand.pct.toFixed(1)}% TIR`
        : `${label} — not enough data`;
      tipEl.textContent = text;
    })
    .on('click', (event)=>{
      const [mx] = d3.pointer(event, svg.node());
      const tHover = xF.invert(mx);
      const d = new Date(tHover);
      const dayStart = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
      const dayMs = 24*60*60*1000;
      setDomainViaBrush(dayStart, dayStart + dayMs);
    })
    .on('mouseleave', ()=>{ tipEl.style.display='none'; });

  // no brush navigation here to keep this view lightweight and stable
}
renderFullRange();

// ---- vertical TIR (unchanged) ----
function updateTIR(idx0,idx1){
  let n=0; let cVL=0,cL=0,cT=0,cH=0,cVH=0;
  for(let i=idx0;i<=idx1;i++){
    const v=values[i];
    if (!(Number.isFinite(v) && v>=0)) continue;
    n++;
    if(v<TH.vlow)cVL++; else if(v<TH.low)cL++;
    else if(v<=TH.high)cT++; else if(v<=TH.vhigh)cH++; else cVH++;
  }
  const pct=x=> n? Math.round(1000*x/n)/10 : 0;

  const bands=[
    {name:"Very High", pct:pct(cVH), color:COLORS.vhigh, goal:"<5%"},
    {name:"High",      pct:pct(cH),  color:COLORS.high,  goal:"<25%"},
    {name:"Target",    pct:pct(cT),  color:COLORS.targ,  goal:"≥70%"},
    {name:"Low",       pct:pct(cL),  color:COLORS.low,   goal:"<4%"},
    {name:"Very Low",  pct:pct(cVL), color:COLORS.vlow,  goal:"<1%"}
  ];

  const Hb=300;
  const container = document.getElementById("tir");
  const Wb = Math.max(320, (container?.getBoundingClientRect()?.width) || 300);
  const Mb={t:20,r:80,b:30,l:30}; // smaller left margin to align bar left
  const svg=d3.select("#tir").selectAll("svg").data([0]).join("svg")
    .attr("width",Wb).attr("height",Hb)
    .style("overflow","visible");

  svg.selectAll("*").remove();

  const scaleY=d3.scaleLinear().domain([0,100]).range([Hb-Mb.b,Mb.t]);

  // draw stacked bar and collect label targets
  const labels=[];
  let acc=0;
  bands.forEach(b=>{
    const y0=scaleY(acc), y1=scaleY(acc+b.pct);
    svg.append("rect").attr("x",Mb.l).attr("y",y1)
      .attr("width",60).attr("height",y0-y1)
      .attr("fill",b.color);
    labels.push({
      text: `${b.name} ${b.pct}% (goal ${b.goal})`,
      center: (y0+y1)/2,
      color: b.color
    });
    acc+=b.pct;
  });

  // resolve label collisions (top→bottom, then bottom→top)
  const minGap = 14; // px between label baselines
  const yMin = Mb.t + 8;
  const yMax = Hb - Mb.b - 8;
  labels.sort((a,b)=>a.center-b.center);
  // forward pass
  for (let i=0;i<labels.length;i++){
    const prev = labels[i-1];
    let y = Math.max(yMin, Math.min(yMax, labels[i].center));
    if (prev && y < prev.y + minGap) y = prev.y + minGap;
    labels[i].y = y;
  }
  // backward pass
  for (let i=labels.length-2;i>=0;i--){
    const next = labels[i+1];
    if (labels[i].y > next.y - minGap) labels[i].y = next.y - minGap;
    if (labels[i].y < yMin) labels[i].y = yMin;
  }

  // render labels with small connectors, styled per band color
  labels.forEach(l=>{
    svg.append("line").attr("x1",Mb.l+60).attr("x2",Mb.l+66)
      .attr("y1",l.y).attr("y2",l.y).attr("stroke", l.color).attr("opacity",0.8);
    svg.append("text").attr("x",Mb.l+70).attr("y",l.y).attr("dy","0.35em")
      .attr("class","pct").attr("fill", l.color).attr("font-size", 11)
      .text(l.text);
  });

  // removed TIR header text for cleaner layout
}

// ---- AGP for selected period ----
function updateAGP(idx0, idx1){
  doUpdateAGP(idx0, idx1);
}

function doUpdateAGP(idx0, idx1){
  const svg = d3.select('#agpSvg');
  svg.selectAll('*').remove();
  const bbox = svg.node().getBoundingClientRect();
  const W = Math.max(360, bbox.width || 600);
  const H = Math.max(220, bbox.height || 260);
  const M = {l:50,r:60,t:20,b:26};

  const dayMs = 24*60*60*1000;
  const samplesPerDay = Math.max(1, Math.round(dayMs/stepMs));
  const byMin = Array.from({length: samplesPerDay}, ()=>[]);
  const daysSet = new Set();

  // collect values by time-of-day bin
  for (let i=idx0;i<=idx1;i++){
    const t = time[i];
    const v = values[i];
    if (!(Number.isFinite(v) && v>=0)) continue;
    const d = new Date(t);
    const midnight = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
    daysSet.add(midnight);
    let bin = Math.round((t - midnight) / stepMs);
    if (bin < 0) bin = 0; else if (bin >= samplesPerDay) bin = samplesPerDay-1;
    byMin[bin].push(v);
  }

  // update meta label (display one fewer day)
  const nDays = daysSet.size || 0;
  const meta = document.getElementById('agpMeta');
  if (meta) meta.textContent = nDays ? `Days used: ${Math.max(0, nDays-1)}` : '';

  const q = (arr,p)=>{
    if (!arr.length) return NaN;
    const a = Float64Array.from(arr).sort();
    const pos = (a.length-1)*p; const b = Math.floor(pos); const r = pos-b;
    return a[b] + (a[Math.min(a.length-1,b+1)]-a[b])*(r||0);
  };
  const series = byMin.map((arr,i)=>({
    t:i,
    p05:q(arr,0.05), p25:q(arr,0.25), p50:q(arr,0.50), p75:q(arr,0.75), p95:q(arr,0.95)
  }));

  // if insufficient data, bail
  const ys = series.flatMap(s=>[s.p05,s.p95]).filter(Number.isFinite);
  if (!ys.length){
    svg.append('text').attr('x',M.l).attr('y',H/2).text('Not enough data in selection to compute AGP');
    return;
  }

  const x = d3.scaleLinear().domain([0, samplesPerDay-1]).range([M.l, W-M.r]);
  const y = d3.scaleLinear().domain(d3.extent(ys)).nice().range([H-M.b, M.t]);

  // target band
  svg.append('rect').attr('x',M.l).attr('width',W-M.l-M.r)
    .attr('y', y(TH.high)).attr('height', y(TH.low)-y(TH.high))
    .attr('fill','#E8F6EC');

  const area = (y0,y1)=>d3.area().defined(d=>Number.isFinite(y0(d))&&Number.isFinite(y1(d)))
    .x(d=>x(d.t)).y0(y0).y1(y1);
  const line = d3.line().defined(d=>Number.isFinite(d.p50)).x(d=>x(d.t)).y(d=>y(d.p50));

  svg.append('path').attr('d', area(d=>y(d.p05), d=>y(d.p95))(series))
    .attr('fill','#f4c7a4').attr('opacity',0.55);
  svg.append('path').attr('d', area(d=>y(d.p25), d=>y(d.p75))(series))
    .attr('fill','#fbd699').attr('opacity',0.8);
  svg.append('path').attr('d', line(series)).attr('stroke','#1a9850').attr('fill','none').attr('stroke-width',2);

  // target lines
  svg.append('line').attr('x1',M.l).attr('x2',W-M.r).attr('y1',y(TH.high)).attr('y2',y(TH.high))
    .attr('stroke','#1a9850').attr('stroke-width',2);
  svg.append('line').attr('x1',M.l).attr('x2',W-M.r).attr('y1',y(TH.low)).attr('y2',y(TH.low))
    .attr('stroke','#1a9850').attr('stroke-width',2);

  // x axis: time-of-day labels every 3 hours
  const perHr = 60*60*1000/stepMs;
  const ticks = d3.range(0, 24+1, 3).map(h=>Math.round(h*perHr));
  const fmtHr = h => (h===0||h===24) ? '12am' : (h<12?`${h}am`:(h===12?'12pm':`${h-12}pm`));
  const axis = d3.axisBottom(x).tickValues(ticks).tickFormat(t=>fmtHr(Math.round(t/perHr)));
  svg.append('g').attr('transform',`translate(0,${H-M.b})`).call(axis);
  svg.append('g').attr('transform',`translate(${M.l},0)`).call(d3.axisLeft(y));
}

// ---- Summary metrics for selected period ----
function updateSummary(idx0, idx1){
  const fmtDate = d3.timeFormat("%b %e, %Y");
  const start = new Date(time[idx0]);
  const end = new Date(time[idx1]);
  const periodText = `${fmtDate(start)} – ${fmtDate(end)}`;
  document.getElementById('sumPeriod').textContent = periodText;

  // slice values and filter valid (not -1)
  const slice = Array.from(values.slice(idx0, idx1+1)).filter(v=>Number.isFinite(v) && v>=0);
  const expected = Math.max(1, idx1 - idx0 + 1);
  const present = slice.length;
  const activePct = 100 * present / expected;
  document.getElementById('sumActive').textContent = `${activePct.toFixed(1)}%`;

  const mean = d3.mean(slice) ?? NaN;
  const variance = d3.variance(slice) ?? 0;
  const sd = Math.sqrt(variance);
  const gmi = Number.isFinite(mean) ? (3.31 + 0.02392 * toMg(mean)) : NaN;
  const cv = Number.isFinite(mean) && mean !== 0 ? (sd/mean*100) : NaN;

  document.getElementById('sumAvg').textContent = isMmol
    ? `${mean?.toFixed(1)} mmol/L`
    : `${Math.round(mean ?? 0)} mg/dL`;
  document.getElementById('sumGmi').textContent = Number.isFinite(gmi) ? `${gmi.toFixed(1)}%` : '—';
  document.getElementById('sumCv').textContent  = Number.isFinite(cv)  ? `${cv.toFixed(1)}%`  : '—';
}


// ---- Show/hide AGP based on selected window length ----
function updateAGPVisibility(idx0, idx1){
  // Count unique days in the current selection
  const dayMs = 24*60*60*1000;
  const daysSet = new Set();
  for (let i=idx0;i<=idx1;i++){
    const d = new Date(time[i]);
    const midnight = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
    daysSet.add(midnight);
  }
  const nDays = daysSet.size || 0;
  const show = nDays >= 7; // require at least 7 days to render AGP

  // Toggle AGP SVG vs. message within fixed-height wrapper
  const svgEl = document.getElementById('agpSvg');
  const msgEl = document.getElementById('agpMsg');
  if (svgEl) svgEl.style.visibility = show ? 'visible' : 'hidden';
  if (msgEl) msgEl.style.display = show ? 'none' : 'flex';

  // Always show the days count in the footer, even when hidden
  const meta = document.getElementById('agpMeta');
  if (meta) meta.textContent = `Days used: ${Math.max(0, nDays-1)}`;

  return show;
}
</script>
</body>
</html>
